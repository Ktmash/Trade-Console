
<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="apple-touch-icon" href="icon-192.png">
<meta name="theme-color" content="#020617">
  <meta charset="UTF-8" />
  <title>Trade Console – Checklist & Journal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #0f172a;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    .app {
      width: 100%;
      max-width: 600px;
      padding: 1.5rem;
    }
    .card {
      position: relative;
      background: #020617;
      border-radius: 0.75rem;
      padding: 1.5rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      border: 1px solid #1e293b;
    }
    h1 {
      margin-top: 0;
      font-size: 1.4rem;
      margin-bottom: 0.25rem;
      color: #f9fafb;
    }
    .subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-bottom: 1rem;
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .card-title-group h1 {
      margin-bottom: 0.1rem;
    }
    .section-label {
      display: inline-block;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #a5b4fc;
      background: rgba(59,130,246,0.1);
      border-radius: 999px;
      padding: 0.25rem 0.6rem;
      margin-bottom: 0.75rem;
    }
    .question-index {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-bottom: 0.25rem;
    }
    .question-text {
      font-size: 1.05rem;
      margin-bottom: 1.25rem;
      line-height: 1.5;
    }
    .buttons {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    button {
      border-radius: 999px;
      border: 1px solid transparent;
      padding: 0.6rem 1.2rem;
      font-size: 0.95rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      background: #111827;
      color: #e5e7eb;
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.1s ease, border-color 0.15s ease;
    }
    button.primary {
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      border-color: #16a34a;
    }
    button.danger {
      background: #ef4444;
      color: #fef2f2;
      border-color: #b91c1c;
    }
    button.secondary {
      background: transparent;
      border-color: #374151;
      color: #9ca3af;
    }
    button.small {
      padding: 0.2rem 0.6rem;
      font-size: 0.75rem;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }
    button:active {
      transform: translateY(0);
      box-shadow: none;
    }
    .progress-bar {
      width: 100%;
      height: 0.35rem;
      border-radius: 999px;
      background: #020617;
      overflow: hidden;
      border: 1px solid #111827;
      margin-bottom: 0.75rem;
    }
    .progress-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, #22c55e, #38bdf8);
      transition: width 0.2s ease;
    }
    .progress-text {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      padding: 0.35rem 0.6rem;
      font-size: 0.75rem;
      margin-top: 0.5rem;
    }
    .status-ok {
      background: rgba(34,197,94,0.08);
      color: #bbf7d0;
      border: 1px solid rgba(34,197,94,0.4);
    }
    .status-fail {
      background: rgba(248,113,113,0.08);
      color: #fecaca;
      border: 1px solid rgba(248,113,113,0.4);
    }
    .status-warn {
      background: rgba(56,189,248,0.08);
      color: #bae6fd;
      border: 1px solid rgba(56,189,248,0.35);
    }
    .summary {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-top: 1rem;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }
    .summary-item {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.35rem 0;
      border-bottom: 1px dashed #111827;
    }
    .summary-item span.answer-yes { color: #bbf7d0; }
    .summary-item span.answer-no { color: #fecaca; }
    .summary-item span.answer-pass { color: #bbf7d0; }
    .summary-item span.answer-fail { color: #fecaca; font-weight: 600; }
    .summary-item span.answer-na { color: #9ca3af; }
    .tip {
      margin-top: 0.75rem;
      font-size: 0.8rem;
      color: #6b7280;
    }
    label {
      display: block;
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 0.15rem;
    }
    input, select, textarea {
      width: 100%;
      padding: 0.4rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.85rem;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px rgba(56,189,248,0.4);
    }
    .journal-form {
      margin-top: 1.25rem;
      padding-top: 1rem;
      border-top: 1px solid #111827;
    }
    .journal-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .journal-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 0.75rem;
      flex-wrap: wrap;
    }
    .history-card {
      margin-top: 1rem;
      padding: 1rem;
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #1e293b;
      max-height: 260px;
      overflow-y: auto;
    }
    #instrumentSettings {
      position: absolute;
      top: 1.25rem;
      right: 1.25rem;
      width: min(340px, 100%);
      max-height: 70vh;
      overflow-y: auto;
      z-index: 30;
    }
    .stats-card {
      margin-top: 1rem;
      padding: 0.85rem 1rem;
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid #1e293b;
    }
    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      color: #9ca3af;
      gap: 0.5rem;
    }
    .history-header-buttons {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
    }
    .history-item {
      padding: 0.5rem 0.65rem;
      border-radius: 0.5rem;
      margin-bottom: 0.4rem;
      border-left: 3px solid #374151;
      background: #020617;
      font-size: 0.8rem;
      cursor: pointer;
    }
    .history-item.win {
      border-left-color: #22c55e;
      background: rgba(34,197,94,0.05);
    }
    .history-item.loss {
      border-left-color: #ef4444;
      background: rgba(248,113,113,0.05);
    }
    .history-item.blocked {
      border-left-color: #f97316;
      background: rgba(249,115,22,0.05);
    }
    .history-line1 {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.15rem;
    }
    .history-line2 {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      color: #9ca3af;
      flex-wrap: wrap;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .badge-pass {
      background: rgba(34,197,94,0.12);
      color: #bbf7d0;
    }
    .badge-fail {
      background: rgba(248,113,113,0.12);
      color: #fecaca;
    }
    .badge-pending {
      background: rgba(148,163,184,0.25);
      color: #e5e7eb;
    }
    .badge-grade {
      background: rgba(56,189,248,0.14);
      color: #bae6fd;
    }
    .stats-bar-bg {
      width: 100%;
      height: 0.45rem;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #111827;
      overflow: hidden;
      margin-bottom: 0.4rem;
    }
    .stats-bar-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      transition: width 0.2s ease;
    }
    .stats-bar-fill.positive {
      background: linear-gradient(90deg, #22c55e, #38bdf8);
    }
    .stats-bar-fill.negative {
      background: linear-gradient(90deg, #ef4444, #f97316);
    }
    .stats-metrics {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      font-size: 0.8rem;
      margin-top: 0.35rem;
      flex-wrap: wrap;
    }
    .stats-metric .label {
      color: #9ca3af;
      font-size: 0.75rem;
      margin-bottom: 0.1rem;
    }
    .stats-metric .value {
      font-weight: 600;
    }
    .stats-metric .sub {
      color: #6b7280;
      font-size: 0.7rem;
      margin-top: 0.05rem;
    }
    .scope-toggle {
      display: flex;
      gap: 0.25rem;
    }
    .scope-toggle button.active {
      background: #1e293b;
      border-color: #38bdf8;
      color: #e5e7eb;
    }
    .tags-line {
      margin-top: 0.25rem;
      display: flex;
      align-items: flex-start;
      gap: 0.25rem;
    }

    .tags-wrap {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      flex: 1 1 auto;
      min-width: 0;
    }
    .tag-pill {
      font-size: 0.65rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid #374151;
      color: #9ca3af;
    }
    .tag-suggestion {
      cursor: pointer;
      opacity: 0.85;
    }
    .tag-suggestion:hover {
      opacity: 1;
      border-color: #38bdf8;
    }

    .trade-num {
      font-size: 0.65rem;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      border: 1px solid #334155;
      background: rgba(15, 23, 42, 0.55);
      color: #e5e7eb;
      margin-left: 0.35rem;
      margin-right: 0;
    
      white-space: nowrap;
    }

    .stats-body {
      transition: filter 0.15s ease;
    }
    .stats-body.blurred {
      filter: blur(6px);
    }
    
    .checklist-review {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #111827;
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .checklist-review strong { color: #e5e7eb; }
    .checklist-review ul { margin: 0.5rem 0 0 1.1rem; padding: 0; }
    .checklist-review li { margin: 0.25rem 0; line-height: 1.35; }
    .checklist-review .fail { color: #fecaca; }
    .checklist-review .warn { color: #f97316; }
    .checklist-review .ok { color: #bbf7d0; }


@media (max-width: 640px) {
      .card { padding: 1.25rem; }
      h1 { font-size: 1.2rem; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <div class="card-header">
        <div class="card-title-group">
          <h1>Trade Console – Checklist & Journal</h1>
          <div class="subtitle">
          Answer honestly. A single failed rule can end the checklist.
          </div>
        </div>
        <button id="homeTopBtn" class="secondary small" type="button" onclick="renderHome()">Home</button>
      </div>

      <div id="cloudStatusContainer"></div>

      <div id="statusContainer"></div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="progress-text">
        <span id="progressLabel">Question 1 of ?</span>
        <span id="sectionLabel"></span>
      </div>

      <div id="questionArea">
        <!-- dynamic -->
      </div>

      <div class="buttons" id="navButtons">
        <!-- dynamic -->
      </div>

      <div class="tip">
        Pro tip: keep this open next to TradingView and force yourself to complete it before clicking Buy or Sell, You Idiot.
      </div>

      <div id="statsContainer" class="stats-card"></div>

      <div id="historyContainer" class="history-card"></div>
      <div id="editContainer" class="history-card" style="display:none;"></div>
      <div id="instrumentSettings" class="history-card" style="display:none;"></div>

      <input id="importFile" type="file" accept=".json,application/json" style="display:none" />
      <input id="tvCsvFile" type="file" accept=".csv,text/csv" style="display:none" />

    </div>
  </div>

  <script>
    const orbQuestions = [
      {
        id: 1,
        section: "Fundemental Analysis",
        text: "Is there any News today that could effect the Market or Trade?",
        hardStop: false,
        failOn: "yes"
      },
      {
        id: 2,
        section: "Psychology",
        text: "Are you prepared to risk 1-2% and withen the weekly 3% drawdown?",
        hardStop: true,
        failOn: "no"
      },
      {
        id: 3,
        section: "Bias & Confluence",
        text: "Do you have at least one Confluence to work with?",
        hardStop: false,
        failOn: "no"
      },
      {
        id: 4,
        section: "Timing & Entry",
        text: "Are we withen the preperation window 8:00 - 9:30EST?",
        hardStop: false,
        failOn: "no"
      },
      {
        id: 5,
        section: "Execution Prep",
        text: "Are your stop-loss and take-profit orders prepared? (1/4 RR, At minimum 1/2 RR)",
        hardStop: true,
        failOn: "no"
      },
      {
        id: 6,
        section: "Entry Trigger",
        text: "At or near the midpoint, Do you see a valid Re-Test Confirmation forming?",
        hardStop: true,
        failOn: "no"
      }
    ];

    const genericQuestions = [
      {
        id: 1,
        section: "Context",
        text: "Is price action aligned with the higher timeframe bias and are you trading in that direction (not counter-trend revenge)?",
        hardStop: true,
        failOn: "no"
      },
      {
        id: 2,
        section: "Level & Trigger",
        text: "Are you entering at a meaningful level (HTF level, clear liquidity area, FVG, etc.) with a clean trigger candle or pattern?",
        hardStop: true,
        failOn: "no"
      },
      {
        id: 3,
        section: "Risk & R/R",
        text: "Is your stop in a logical place (not arbitrary) and is the reward-to-risk at least 2R with room for price to move cleanly?",
        hardStop: true,
        failOn: "no"
      },
      {
        id: 4,
        section: "News & Session Rules",
        text: "Are you inside your allowed trading window and free of major news or random chop times for this instrument?",
        hardStop: true,
        failOn: "no"
      },
      {
        id: 5,
        section: "Psychology & Daily Limits",
        text: "Are you calm, not tilted, and still inside your daily loss / max trades limits (no chasing, no FOMO, no 'one more')?",
        hardStop: true,
        failOn: "no"
      }
    ];


    const defaultChecklists = [
      { key: "orb", name: "ORB Midpoint Checklist", questions: orbQuestions },
      { key: "generic", name: "Generic Checklist", questions: genericQuestions }
    ];


    let currentQuestions = orbQuestions;
    let currentChecklistKey = "orb";
    let checklistActive = false;
    let currentIndex = 0;
    let answers = new Array(currentQuestions.length).fill(null);
    let failed = false;
    let failReason = "";
    let tradeHistory = [];
    let editingTradeId = null;


    function setHomeMode(isHome) {
      const stats = document.getElementById("statsContainer");
      const history = document.getElementById("historyContainer");
      const homeBtn = document.getElementById("homeTopBtn");
      if (stats) {
        stats.style.display = isHome ? "block" : "none";
      }
      if (history) {
        history.style.display = isHome ? "block" : "none";
      }
      // Hide the Home button when we're already on the Home screen.
      if (homeBtn) {
        homeBtn.style.display = isHome ? "none" : "inline-flex";
      }
    
      const cloud = document.getElementById("cloudStatusContainer");
      if (cloud) {
        cloud.style.display = isHome ? "block" : "none";
      }

      // On the Home screen, the progress UI just adds clutter (Ready/Home pills).
      const progressBarEl = document.querySelector(".progress-bar");
      const progressTextEl = document.querySelector(".progress-text");
      if (progressBarEl) progressBarEl.style.display = isHome ? "none" : "block";
      if (progressTextEl) progressTextEl.style.display = isHome ? "none" : "flex";

    }

    let settings = {
      dollarsPerR: 50, // legacy, unused now
      pnlBlurred: false,
      instruments: [],
      lastInstrumentId: "",
      tagSuggestions: ["ORB","A+ setup","News day","FOMO","Overtraded","Rule break"],
      checklists: [],
      lastChecklistKey: "orb"
    };
    
    let statsScope = "all"; // "all" or "today"
    let settingsPanelOpen = false;

    function handleSettingsOutsideClick(e) {
      const panel = document.getElementById("instrumentSettings");
      if (!panel || !settingsPanelOpen) return;
      if (panel.contains(e.target)) return;
      const isSettingsButton = e.target.closest && e.target.closest("button[onclick*='toggleSettings']");
      if (isSettingsButton) return;
      panel.style.display = "none";
      settingsPanelOpen = false;
      document.removeEventListener("mousedown", handleSettingsOutsideClick, true);
    }


    const questionArea = document.getElementById("questionArea");
    const navButtons = document.getElementById("navButtons");
    const progressFill = document.getElementById("progressFill");
    const progressLabel = document.getElementById("progressLabel");
    const sectionLabel = document.getElementById("sectionLabel");
    const statusContainer = document.getElementById("statusContainer");
    const cloudStatusContainer = document.getElementById("cloudStatusContainer");

    const CLOUD_ENDPOINTS = {
      ping: "/api/cloud/ping",
      settings: "/api/cloud/settings",
      trades: "/api/cloud/trades"
    };
    const CLOUD_DIRTY_SETTINGS_KEY = "orb_midpoint_cloud_dirty_settings_v1";
    const CLOUD_DIRTY_TRADES_KEY = "orb_midpoint_cloud_dirty_trades_v1";

    function setCloudDirty(kind, dirty) {
      try {
        const k = (kind === "settings") ? CLOUD_DIRTY_SETTINGS_KEY : CLOUD_DIRTY_TRADES_KEY;
        localStorage.setItem(k, dirty ? "1" : "0");

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {}
    }

    function getCloudDirty(kind) {
      try {
        const k = (kind === "settings") ? CLOUD_DIRTY_SETTINGS_KEY : CLOUD_DIRTY_TRADES_KEY;
        return localStorage.getItem(k) === "1";

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) { return false; }
    }



    let cloudEnabled = true;
    let cloudKey = "";
    let cloudMuteSaves = false;
    let cloudSaveSettingsTimer = null;
    let cloudSaveTradesTimer = null;

    let cloudState = {
      status: "init", // init | syncing | ok | error | off
      message: "Connecting…",
      lastSync: null,
      lastError: null,
      requiresKey: false
    };

    function loadCloudPrefs() {
      try {
        cloudEnabled = localStorage.getItem("orb_midpoint_cloud_enabled_v1") !== "off";
        cloudKey = localStorage.getItem("orb_midpoint_cloud_key_v1") || "";

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {}
    }

    function saveCloudPrefs() {
      try {
        localStorage.setItem("orb_midpoint_cloud_enabled_v1", cloudEnabled ? "on" : "off");
        localStorage.setItem("orb_midpoint_cloud_key_v1", cloudKey || "");

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {}
    }

    function cloudHeaders() {
      const h = { "Content-Type": "application/json" };
      if (cloudKey) h["X-Sync-Key"] = cloudKey;
      return h;
    }

    function setCloudStatus(status, message, err) {
      cloudState.status = status;
      if (message) cloudState.message = message;
      cloudState.lastError = err ? (err.message || String(err)) : null;
      renderCloudStatus();
    }

    function renderCloudStatus() {
      if (!cloudStatusContainer) return;
      cloudStatusContainer.innerHTML = "";

      const pill = document.createElement("div");
      let cls = "status-pill";
      if (!cloudEnabled || cloudState.status === "off") cls = "status-pill";
      else if (cloudState.status === "ok") cls = "status-pill status-ok";
      else if (cloudState.status === "error") cls = "status-pill status-fail";
      else cls = "status-pill status-warn";

      pill.className = cls;

      const last = cloudState.lastSync ? new Date(cloudState.lastSync).toLocaleString() : "";
      const msg = cloudEnabled ? (cloudState.message || "…") : "OFF";
      const hint = cloudEnabled && last ? `<span style="color:#9ca3af;"> • ${last}</span>` : "";

      pill.innerHTML = `
        <span><strong>Cloud Sync:</strong> ${msg}${hint}</span>
        <span style="margin-left:auto;display:inline-flex;gap:0.35rem;align-items:center;">
          <button class="secondary small" type="button" id="cloudSyncNowBtn">Sync</button>
          <button class="secondary small" type="button" id="cloudKeyBtn">Key</button>
          <button class="secondary small" type="button" id="cloudToggleBtn">${cloudEnabled ? "Off" : "On"}</button>
        </span>
      `;

      cloudStatusContainer.appendChild(pill);

      const syncBtn = document.getElementById("cloudSyncNowBtn");
      if (syncBtn) {
        syncBtn.onclick = () => {
          if (!cloudEnabled) return;
          cloudSyncNow();
        };
      }

      const toggleBtn = document.getElementById("cloudToggleBtn");
      if (toggleBtn) {
        toggleBtn.onclick = () => {
          cloudEnabled = !cloudEnabled;
          saveCloudPrefs();
          if (!cloudEnabled) {
            setCloudStatus("off", "OFF");
          } else {
            setCloudStatus("init", "Connecting…");
            bootstrapCloudSync();
          }
        };
      }

      const keyBtn = document.getElementById("cloudKeyBtn");
      if (keyBtn) {
        keyBtn.onclick = () => {
          const existing = cloudKey || "";
          const entered = prompt("Cloud Sync Key (leave blank if not using one):", existing);
          if (entered === null) return;
          cloudKey = String(entered || "").trim();
          saveCloudPrefs();
          cloudSyncNow();
        };
      }

      // Show error details (tiny) if we have them.
      if (cloudEnabled && cloudState.lastError && cloudState.status === "error") {
        const errLine = document.createElement("div");
        errLine.style.marginTop = "0.35rem";
        errLine.style.fontSize = "0.7rem";
        errLine.style.color = "#9ca3af";
        errLine.textContent = cloudState.lastError;
        cloudStatusContainer.appendChild(errLine);
      }
    }

    async function cloudPing() {
      const res = await fetch(CLOUD_ENDPOINTS.ping, { headers: cloudHeaders(), cache: "no-store" });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`Cloud ping failed (${res.status}): ${t}`);
      }
      const j = await res.json();
      cloudState.requiresKey = !!j.requiresKey;
      return j;
    }

    async function cloudGetJson(url) {
      const res = await fetch(url, { headers: cloudHeaders(), cache: "no-store" });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`Cloud GET failed (${res.status}): ${t}`);
      }
      return res.json();
    }

    // -----------------------------
// Cloud write lock + write serialization (prevents GitHub SHA conflicts from overlapping syncs)
// -----------------------------
const CLOUD_WRITE_LOCK_KEY = "orb_midpoint_cloud_write_lock_v1";
const cloudClientId = (typeof crypto !== "undefined" && crypto.randomUUID) ? crypto.randomUUID() : ("tab_" + Math.random().toString(16).slice(2));

function cloudNowMs() { return Date.now(); }

async function cloudSleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function tryAcquireCloudWriteLock(ttlMs = 15000) {
  try {
    const raw = localStorage.getItem(CLOUD_WRITE_LOCK_KEY);
    const now = cloudNowMs();
    if (raw) {
      const cur = JSON.parse(raw);
      if (cur && cur.owner && cur.until && cur.until > now && cur.owner !== cloudClientId) {
        return false;
      }
    }
    const next = { owner: cloudClientId, until: now + ttlMs };
    localStorage.setItem(CLOUD_WRITE_LOCK_KEY, JSON.stringify(next));
    // Re-check we actually hold it (best-effort; localStorage isn't truly atomic across tabs)
    const verify = JSON.parse(localStorage.getItem(CLOUD_WRITE_LOCK_KEY) || "{}");
    return verify.owner === cloudClientId;
  } catch (e) {
    // If localStorage is unavailable, just proceed without cross-tab locking.
    return true;
  }
}

function releaseCloudWriteLock() {
  try {
    const raw = localStorage.getItem(CLOUD_WRITE_LOCK_KEY);
    if (!raw) return;
    const cur = JSON.parse(raw);
    if (cur && cur.owner === cloudClientId) localStorage.removeItem(CLOUD_WRITE_LOCK_KEY);
  } catch (e) {}
}

async function acquireCloudWriteLockWait(maxWaitMs = 6000) {
  const start = cloudNowMs();
  while (cloudNowMs() - start < maxWaitMs) {
    if (tryAcquireCloudWriteLock()) return true;
    await cloudSleep(120);
  }
  throw new Error("Cloud sync busy in another tab — close extra Trade Console tabs and try again.");
}

async function cloudPutJson(url, payload) {
  // Serialize PUTs within this tab to avoid overlapping saves racing each other.
  if (!cloudPutJson._queue) cloudPutJson._queue = Promise.resolve();

  const run = async () => {
    await acquireCloudWriteLockWait();
    try {
      for (let attempt = 0; attempt < 3; attempt++) {
        const res = await fetch(url, { method: "PUT", headers: cloudHeaders(), body: JSON.stringify({ data: payload }) });
        if (res.ok) return res.json();

        const t = await res.text().catch(() => "");
        // If backend returns 409, it means conflict storm; brief backoff then retry.
        if (res.status === 409) {
          await cloudSleep(180 * (attempt + 1));
          continue;
        }
        throw new Error(`Cloud PUT failed (${res.status}): ${t}`);
      }
      throw new Error("Cloud PUT failed (409): conflict retry limit reached");
    } finally {
      releaseCloudWriteLock();
    }
  };

  const p = cloudPutJson._queue.then(run, run);
  // Keep the queue alive even if a PUT fails.
  cloudPutJson._queue = p.catch(() => {});
  return p;
}


    async function cloudLoadAll() {
      const [cloudSettings, cloudTrades] = await Promise.all([
        cloudGetJson(CLOUD_ENDPOINTS.settings),
        cloudGetJson(CLOUD_ENDPOINTS.trades)
      ]);
      return { cloudSettings, cloudTrades };
    }

    // -----------------------------
    // Cloud merge helpers (prevents "pull overwrote my newest trade")
    // -----------------------------
    function safeParseTime(val) {
      if (!val) return 0;
      const t = Date.parse(val);
      return isFinite(t) ? t : 0;
    }

    function tradeTimeValueGlobal(t) {
      if (!t) return 0;
      const ts = t.timestamp ? Date.parse(t.timestamp) : NaN;
      if (isFinite(ts)) return ts;
      const alt = t.time || t.date || t.datetime || t.dateTime;
      const ts2 = alt ? Date.parse(alt) : NaN;
      return isFinite(ts2) ? ts2 : 0;
    }

    function hashString(str) {
      // FNV-1a-ish
      let h = 2166136261;
      const s = String(str || "");
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0).toString(16);
    }

    function deterministicTradeId(trade) {
      const ts = trade && trade.timestamp ? trade.timestamp : "";
      const parts = [
        ts,
        trade && (trade.symbol || trade.instrumentId) || "",
        trade && trade.direction || "",
        trade && trade.entry || "",
        trade && trade.sl || "",
        trade && trade.tp1 || "",
        trade && trade.tp2 || "",
        trade && trade.contracts || "",
        trade && trade.pnl !== null && trade.pnl !== undefined ? trade.pnl : "",
        trade && trade.notes || ""
      ].join("|");
      return "t_" + hashString(parts);
    }

    function ensureTradeMeta(trade) {
      if (!trade || typeof trade !== "object") return trade;

      // Normalize timestamp if older shapes exist
      if (!trade.timestamp) {
        const alt = trade.time || trade.date || trade.datetime || trade.dateTime;
        if (alt) {
          const d = new Date(alt);
          if (!isNaN(d.getTime())) trade.timestamp = d.toISOString();
        }
      }
      if (!trade.timestamp) trade.timestamp = new Date().toISOString();

      // Stable id: keep existing, otherwise generate deterministically so local+cloud can dedupe.
      if (!trade.id) trade.id = deterministicTradeId(trade);

      // updatedAt helps resolve conflicts during merge
      if (!trade.updatedAt) trade.updatedAt = trade.timestamp;

      return trade;
    }

    function touchTrade(trade) {
      if (!trade || typeof trade !== "object") return;
      const now = new Date().toISOString();
      trade.updatedAt = now;
      if (!trade.timestamp) trade.timestamp = now;
      if (!trade.id) trade.id = deterministicTradeId(trade);
    }

    function upgradeTradesArray(arr) {
      if (!Array.isArray(arr)) return [];
      return arr.map(t => ensureTradeMeta(Object.assign({}, t)));
    }

    function mergeTradesArrays(localArr, remoteArr) {
      const map = new Map();

      const put = (trade, preferLocalOnTie) => {
        if (!trade || typeof trade !== "object") return;
        ensureTradeMeta(trade);
        const key = String(trade.id);
        const existing = map.get(key);
        if (!existing) {
          map.set(key, trade);
          return;
        }
        const a = safeParseTime(existing.updatedAt || existing.timestamp);
        const b = safeParseTime(trade.updatedAt || trade.timestamp);
        if (b > a) map.set(key, trade);
        else if (b === a && preferLocalOnTie) map.set(key, trade);
      };

      // Remote first, then local (local wins exact ties)
      (remoteArr || []).forEach(t => put(ensureTradeMeta(Object.assign({}, t)), false));
      (localArr || []).forEach(t => put(ensureTradeMeta(Object.assign({}, t)), true));

      return Array.from(map.values());
    }

    function mergeStringArray(primary, secondary) {
      const out = [];
      const seen = new Set();
      const add = (v) => {
        const s = String(v || "").trim();
        if (!s) return;
        const k = s.toLowerCase();
        if (seen.has(k)) return;
        seen.add(k);
        out.push(s);
      };
      (primary || []).forEach(add);
      (secondary || []).forEach(add);
      return out;
    }

    function mergeById(primary, secondary) {
      const map = new Map();
      (secondary || []).forEach(o => { if (o && o.id) map.set(String(o.id), o); });
      (primary || []).forEach(o => { if (o && o.id) map.set(String(o.id), o); });
      return Array.from(map.values());
    }

    function mergeByKey(primary, secondary) {
      const map = new Map();
      (secondary || []).forEach(o => { if (o && o.key) map.set(String(o.key), o); });
      (primary || []).forEach(o => { if (o && o.key) map.set(String(o.key), o); });
      return Array.from(map.values());
    }

    function mergeSettingsObjects(localS, remoteS) {
      const local = (localS && typeof localS === "object") ? localS : {};
      const remote = (remoteS && typeof remoteS === "object") ? remoteS : {};
      const localTs = safeParseTime(local.updatedAt);
      const remoteTs = safeParseTime(remote.updatedAt);

      // Prefer whichever was updated more recently (fallback: if we know local is dirty, prefer local)
      const preferLocal = getCloudDirty("settings") || (localTs > remoteTs);

      const primary = preferLocal ? local : remote;
      const secondary = preferLocal ? remote : local;

      const merged = Object.assign({}, secondary, primary);

      merged.tagSuggestions = mergeStringArray(
        Array.isArray(primary.tagSuggestions) ? primary.tagSuggestions : [],
        Array.isArray(secondary.tagSuggestions) ? secondary.tagSuggestions : []
      );

      merged.instruments = mergeById(
        Array.isArray(primary.instruments) ? primary.instruments : [],
        Array.isArray(secondary.instruments) ? secondary.instruments : []
      );

      merged.checklists = mergeByKey(
        Array.isArray(primary.checklists) ? primary.checklists : [],
        Array.isArray(secondary.checklists) ? secondary.checklists : []
      );

      merged.updatedAt = preferLocal ? (local.updatedAt || new Date().toISOString()) : (remote.updatedAt || new Date().toISOString());
      return merged;
    }

    function computeTradeNumberMap(trades) {
      const arr = Array.isArray(trades) ? trades.map(t => ensureTradeMeta(Object.assign({}, t))) : [];
      arr.sort((a, b) => {
        const dt = tradeTimeValueGlobal(a) - tradeTimeValueGlobal(b);
        if (dt !== 0) return dt;
        return String(a.id).localeCompare(String(b.id));
      });
      const map = new Map();
      arr.forEach((t, idx) => map.set(String(t.id), idx + 1)); // oldest = 1
      return map;
    }


    
    async function cloudSaveSettingsNow() {
      if (!cloudEnabled || cloudMuteSaves) return;

      // Merge before pushing (prevents "last writer wins" wiping another device).
      let remote = null;
      try { remote = await cloudGetJson(CLOUD_ENDPOINTS.settings); } catch (e) { remote = null; }

      const merged = mergeSettingsObjects(settings, (remote && typeof remote === "object") ? remote : {});
      settings = Object.assign(settings, merged);
      if (!Array.isArray(settings.instruments)) settings.instruments = [];
      ensureDefaultInstruments();
      ensureDefaultChecklists();
      normalizeChecklists();
      saveSettings(true);

      await cloudPutJson(CLOUD_ENDPOINTS.settings, settings);
    }

    
    async function cloudSaveTradesNow() {
      if (!cloudEnabled || cloudMuteSaves) return;

      // Merge before pushing (prevents overwriting trades created on another device).
      let remote = null;
      try { remote = await cloudGetJson(CLOUD_ENDPOINTS.trades); } catch (e) { remote = null; }

      const merged = mergeTradesArrays(
        upgradeTradesArray(tradeHistory),
        upgradeTradesArray(Array.isArray(remote) ? remote : [])
      );

      tradeHistory = merged;
      saveTradeHistory(true);

      await cloudPutJson(CLOUD_ENDPOINTS.trades, tradeHistory);
    }

    
    function scheduleCloudSaveSettings() {
      if (!cloudEnabled || cloudMuteSaves) return;
      if (cloudSaveSettingsTimer) clearTimeout(cloudSaveSettingsTimer);
      cloudSaveSettingsTimer = setTimeout(async () => {
        if (!cloudEnabled || cloudMuteSaves) return;
        try {
          setCloudStatus("syncing", "Syncing…");
          await cloudSaveSettingsNow();
          setCloudDirty("settings", false);
          cloudState.lastSync = new Date().toISOString();
          setCloudStatus("ok", "Up to date");
  
      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
          setCloudDirty("settings", true);
          setCloudStatus("error", "Sync error", e);
        }
      }, 1200);
    }

    function scheduleCloudSaveTrades() {
      if (!cloudEnabled || cloudMuteSaves) return;
      if (cloudSaveTradesTimer) clearTimeout(cloudSaveTradesTimer);
      cloudSaveTradesTimer = setTimeout(async () => {
        if (!cloudEnabled || cloudMuteSaves) return;
        try {
          setCloudStatus("syncing", "Syncing…");
          await cloudSaveTradesNow();
          setCloudDirty("trades", false);
          cloudState.lastSync = new Date().toISOString();
          setCloudStatus("ok", "Up to date");
  
      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
          setCloudDirty("trades", true);
          setCloudStatus("error", "Sync error", e);
        }
      }, 1200);
    }

    
    async function cloudSyncNow() {
      if (!cloudEnabled) return;
      // Cancel any pending debounced saves so they don't race this sync.
      if (cloudSaveSettingsTimer) { clearTimeout(cloudSaveSettingsTimer); cloudSaveSettingsTimer = null; }
      if (cloudSaveTradesTimer) { clearTimeout(cloudSaveTradesTimer); cloudSaveTradesTimer = null; }
      let mergedApplied = false;
      try {
        setCloudStatus("syncing", "Syncing…");
        await cloudPing();
        const { cloudSettings, cloudTrades } = await cloudLoadAll();

        const localSettings = Object.assign({}, settings);
        const localTrades = Array.isArray(tradeHistory) ? tradeHistory.slice() : [];

        const remoteSettings = (cloudSettings && typeof cloudSettings === "object") ? cloudSettings : {};
        const remoteTrades = Array.isArray(cloudTrades) ? cloudTrades : [];

        const mergedSettings = mergeSettingsObjects(localSettings, remoteSettings);
        const mergedTrades = mergeTradesArrays(
          upgradeTradesArray(localTrades),
          upgradeTradesArray(remoteTrades)
        );

        // Apply merged → local
        cloudMuteSaves = true;

        settings = Object.assign(settings, mergedSettings);
        if (!Array.isArray(settings.instruments)) settings.instruments = [];
        ensureDefaultInstruments();
        ensureDefaultChecklists();
        normalizeChecklists();
        saveSettings(true);

        tradeHistory = mergedTrades;
        saveTradeHistory(true);

        cloudMuteSaves = false;
        mergedApplied = true;

        // Push merged → cloud (so we never lose local-only trades/settings)
        await Promise.all([
          cloudPutJson(CLOUD_ENDPOINTS.settings, settings),
          cloudPutJson(CLOUD_ENDPOINTS.trades, tradeHistory)
        ]);

        setCloudDirty("settings", false);
        setCloudDirty("trades", false);

        renderTradeHistory();
        renderInstrumentSettings();
        renderHome();

        cloudState.lastSync = new Date().toISOString();
        setCloudStatus("ok", "Up to date");

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        // If we already merged locally but failed to push, mark as dirty so the next sync will retry.
        if (mergedApplied) {
          setCloudDirty("settings", true);
          setCloudDirty("trades", true);
        }
        setCloudStatus("error", "Sync error", e);
      } finally {
        cloudMuteSaves = false;
      }
    }


    async function bootstrapCloudSync() {
      loadCloudPrefs();
      renderCloudStatus();
      if (!cloudEnabled) {
        setCloudStatus("off", "OFF");
        return;
      }
      if (typeof navigator !== "undefined" && navigator.onLine === false) {
        setCloudStatus("error", "Offline");
        return;
      }
      // Initial sync
      await cloudSyncNow();
    }

    function ensureDefaultInstruments() {
      if (!Array.isArray(settings.instruments) || !settings.instruments.length) {
        settings.instruments = [
          { id: "MES", label: "MES (Micro ES)", tickSize: 0.25, tickValue: 1.25, commissionPerContract: 2.00 },
          { id: "MNQ", label: "MNQ (Micro NQ)", tickSize: 0.25, tickValue: 0.50, commissionPerContract: 0 },
          { id: "MGC", label: "MGC (Micro Gold)", tickSize: 0.1,  tickValue: 1.00, commissionPerContract: 0 }
        ];
      }

      // Migration: older settings may not have commissionPerContract
      (settings.instruments || []).forEach(inst => {
        if (!inst || typeof inst !== "object") return;
        if (inst.commissionPerContract === undefined || inst.commissionPerContract === null || inst.commissionPerContract === "") {
          inst.commissionPerContract = 0;
        }
      });
    }



    function ensureDefaultChecklists() {
      // Make sure we always have a sane checklist structure.
      if (!Array.isArray(settings.checklists)) {
        settings.checklists = [];
      }

      // Determine if there is at least one checklist with at least one non-empty question.
      const hasValidChecklist = settings.checklists.some(c =>
        c &&
        Array.isArray(c.questions) &&
        c.questions.some(q => q && typeof q.text === "string" && q.text.trim() !== "")
      );

      // If nothing useful exists yet (or things are corrupted / empty),
      // reset to the built-in defaults (ORB + Generic).
      if (!settings.checklists.length || !hasValidChecklist) {
        settings.checklists = defaultChecklists.map(c => ({
          key: c.key,
          name: c.name,
          questions: (c.questions || []).map((q, idx) => ({
            id: idx + 1,
            section: q.section || "",
            text: q.text || "",
            hardStop: !!q.hardStop,
            failOn: q.failOn || "no"
          }))
        }));
        return;
      }

      // Otherwise, make sure each default exists and has questions.
      const byKey = new Map();
      settings.checklists.forEach(c => {
        if (c && typeof c.key === "string" && c.key.trim() !== "") {
          byKey.set(c.key, c);
        }
      });

      defaultChecklists.forEach(def => {
        const existing = byKey.get(def.key);
        if (!existing) {
          // Add missing default checklist
          settings.checklists.push({
            key: def.key,
            name: def.name,
            questions: (def.questions || []).map((q, idx) => ({
              id: idx + 1,
              section: q.section || "",
              text: q.text || "",
              hardStop: !!q.hardStop,
              failOn: q.failOn || "no"
            }))
          });
          return;
        }

        // Ensure there is a name
        if (!existing.name) {
          existing.name = def.name;
        }

        // If this default checklist has no questions (or invalid structure),
        // repopulate from its default template.
        if (!Array.isArray(existing.questions) || !existing.questions.length) {
          existing.questions = (def.questions || []).map((q, idx) => ({
            id: idx + 1,
            section: q.section || "",
            text: q.text || "",
            hardStop: !!q.hardStop,
            failOn: q.failOn || "no"
          }));
        }
      });
    }

function normalizeChecklists() {
      if (!Array.isArray(settings.checklists)) {
        settings.checklists = [];
        return;
      }
      const used = new Set();
      function makeKey(base) {
        let k = base || "checklist";
        let i = 1;
        while (!k || used.has(k)) {
          k = (base || "checklist") + "_" + i;
          i++;
        }
        used.add(k);
        return k;
      }
      settings.checklists.forEach((c, idx) => {
        if (!c || typeof c !== "object") {
          const k = makeKey("checklist" + (idx + 1));
          settings.checklists[idx] = {
            key: k,
            name: "Checklist " + (idx + 1),
            questions: []
          };
          return;
        }
        let key = (typeof c.key === "string" ? c.key.trim() : "") || "";
        if (!key) {
          const name = (c.name || "").toLowerCase();
          if (name.includes("orb")) key = "orb";
          else if (name.includes("generic")) key = "generic";
          else key = "custom" + (idx + 1);
        }
        if (used.has(key)) {
          key = makeKey(key);
        } else {
          used.add(key);
        }
        c.key = key;
        if (!Array.isArray(c.questions)) {
          c.questions = [];
        }
        c.questions = c.questions.map((q, i) => {
          q = q || {};
          const failOnRaw = (q.failOn === "yes" || q.failOn === "no") ? q.failOn : "no";
          const hard = (typeof q.hardStop === "boolean") ? q.hardStop : !!q.hardStop;
          return {
            id: i + 1,
            section: q.section || "",
            text: q.text || "",
            hardStop: hard,
            failOn: failOnRaw
          };
        });
      });
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem("orb_midpoint_settings_v1");
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === "object") {
            settings = Object.assign(settings, parsed);
          }
        }

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        console.warn("Could not load settings", e);
      }
      if (!Array.isArray(settings.instruments)) {
        settings.instruments = [];
      }
      ensureDefaultInstruments();
      ensureDefaultChecklists();
      normalizeChecklists();
    }

    function saveSettings(skipCloud) {
      if (!skipCloud) {
        // Mark settings as recently updated so cloud merge can resolve conflicts.
        settings.updatedAt = new Date().toISOString();
      }
      try {
        localStorage.setItem("orb_midpoint_settings_v1", JSON.stringify(settings));

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        console.warn("Could not save settings", e);
      }
      if (!skipCloud) {
        try { scheduleCloudSaveSettings(); } catch (e) {}
      }
    }

    function loadStatsScope() {
      try {
        const raw = localStorage.getItem("orb_midpoint_stats_scope_v1");
        if (raw === "all" || raw === "today") {
          statsScope = raw;
        }

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        console.warn("Could not load stats scope", e);
      }
    }

    function saveStatsScope() {
      try {
        localStorage.setItem("orb_midpoint_stats_scope_v1", statsScope);

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        console.warn("Could not save stats scope", e);
      }
    }

    function setStatsScope(scope) {
      if (scope !== "all" && scope !== "today") return;
      statsScope = scope;
      saveStatsScope();
      renderStats();
    }

    function togglePnlVisibility() {
      settings.pnlBlurred = !settings.pnlBlurred;
      saveSettings();
      applyPnlBlurState();
    }

    function applyPnlBlurState() {
      const body = document.getElementById("statsBody");
      const btn = document.getElementById("pnlToggleBtn");
      if (!body || !btn) return;
      if (settings.pnlBlurred) {
        body.classList.add("blurred");
        btn.textContent = "Show PnL";
      } else {
        body.classList.remove("blurred");
        btn.textContent = "Hide PnL";
      }
    }

    function loadTradeHistory() {
      try {
        const raw = localStorage.getItem("orb_midpoint_trades_v1");
        if (raw) {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            tradeHistory = upgradeTradesArray(parsed);
          }
        }

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        console.warn("Could not load trade history", e);
        tradeHistory = [];
      }
    }

    function saveTradeHistory(skipCloud) {
      try {
        localStorage.setItem("orb_midpoint_trades_v1", JSON.stringify(tradeHistory));

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {
        console.warn("Could not save trade history", e);
      }
      if (!skipCloud) {
        try { scheduleCloudSaveTrades(); } catch (e) {}
      }
    }

    function addTrade(trade) {
      ensureTradeMeta(trade);
      touchTrade(trade);
      tradeHistory.unshift(trade);
      if (tradeHistory.length > 500) {
        tradeHistory = tradeHistory.slice(0, 500);
      }
      saveTradeHistory();
      renderTradeHistory();
    }

    function clearTradeHistory() {
      if (!confirm("Clear all stored trades from this browser? This cannot be undone.")) return;
      tradeHistory = [];
      saveTradeHistory();
      renderTradeHistory();
    }

    
    function makeTradeFingerprint(trade) {
      function norm(v) {
        if (v === null || v === undefined) return "";
        return String(v).trim();
      }
      return [
        norm(trade.timestamp),
        norm(trade.symbol),
        norm(trade.instrumentId),
        norm(trade.direction),
        norm(trade.contracts),
        norm(trade.entry),
        norm(trade.sl),
        norm(trade.tp1),
        norm(trade.tp2),
        norm(trade.result),
        norm(trade.pnl)
      ].join("|");
    }

    function mergeTradeArrays(existing, incoming) {
      const seen = new Set();
      const out = [];

      function addIfNew(trade) {
        const fp = makeTradeFingerprint(trade || {});
        if (seen.has(fp)) return;
        seen.add(fp);
        out.push(trade);
      }

      (existing || []).forEach(addIfNew);
      (incoming || []).forEach(addIfNew);
      return out;
    }

function csvEscape(value) {
      if (value === null || value === undefined) return "";
      const str = String(value).replace(/"/g, '""');
      if (/[,"\n]/.test(str)) {
        return `"${str}"`;
      }
      return str;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportHistoryCSV() {
      if (!tradeHistory.length) {
        alert("No trades to export.");
        return;
      }
      const headers = [
        "timestamp","symbol","direction","entry","sl","tp1","tp2",
        "result","pnl","rMultiple","checklistPassed","checklistScore",
        "checklistKey","checklistName","failReason","notes","tags",
        "instrumentId","contracts"
      ];
      const rows = [headers.join(",")];
      tradeHistory.forEach(trade => {
        const tagsStr = Array.isArray(trade.tags)
          ? trade.tags.join("; ")
          : (trade.tags || "");
        const row = [
          csvEscape(trade.timestamp),
          csvEscape(trade.symbol),
          csvEscape(trade.direction),
          csvEscape(trade.entry),
          csvEscape(trade.sl),
          csvEscape(trade.tp1),
          csvEscape(trade.tp2),
          csvEscape(trade.result),
          csvEscape(trade.pnl),
          csvEscape(trade.rMultiple),
          csvEscape(trade.checklistPassed),
          csvEscape(trade.checklistScore),
          csvEscape(trade.checklistKey),
          csvEscape(trade.checklistName),
          csvEscape(trade.failReason),
          csvEscape(trade.notes),
          csvEscape(tagsStr),
          csvEscape(trade.instrumentId),
          csvEscape(trade.contracts)
        ];
        rows.push(row.join(","));
      });
      const csv = rows.join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const now = new Date();
      const ts = now.toISOString().replace(/[:T]/g, "-").split(".")[0];
      downloadBlob(blob, `orb_trades_${ts}.csv`);
    }

    function exportHistoryJSON() {
      if (!tradeHistory.length) {
        alert("No trades to export.");
        return;
      }
      const json = JSON.stringify(tradeHistory, null, 2);
      const blob = new Blob([json], { type: "application/json" });
      const now = new Date();
      const ts = now.toISOString().replace(/[:T]/g, "-").split(".")[0];
      downloadBlob(blob, `orb_trades_${ts}.json`);
    }

    function triggerImport() {
      const input = document.getElementById("importFile");
      if (input) {
        input.value = "";
        input.click();
      }
    }

    function handleImportFile(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const text = e.target.result;
          const parsed = JSON.parse(text);
          if (!Array.isArray(parsed)) {
            alert("JSON must be an array of trade objects (export format).");
            return;
          }
          tradeHistory = mergeTradeArrays(tradeHistory, parsed);
          tradeHistory.sort((a, b) => {
            const ta = new Date(a.timestamp || 0).getTime();
            const tb = new Date(b.timestamp || 0).getTime();
            return tb - ta;
          });
          if (tradeHistory.length > 500) {
            tradeHistory = tradeHistory.slice(0, 500);
          }
          saveTradeHistory();
          renderTradeHistory();
          alert("Imported trades from JSON.");
        } catch (err) {
          console.error(err);
          alert("Failed to parse JSON file.");
        }
      };
      reader.readAsText(file);
    }

    
    function triggerImportTvCsv() {
      const input = document.getElementById("tvCsvFile");
      if (input) {
        input.value = "";
        input.click();
      }
    }

    
    function parseCsvText(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) return { headers: [], rows: [] };

      function parseLine(line) {
        const result = [];
        let cur = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
              cur += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (ch === ',' && !inQuotes) {
            result.push(cur);
            cur = "";
          } else {
            cur += ch;
          }
        }
        result.push(cur);
        return result;
      }

      const headers = parseLine(lines[0]).map(h => h.trim());
      const rows = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const cols = parseLine(line).map(c => c.trim().replace(/^"|"$/g, ""));
        if (!cols.length || cols.every(c => c === "")) continue;
        if (cols.length < headers.length) {
          while (cols.length < headers.length) cols.push("");
        } else if (cols.length > headers.length) {
          cols.length = headers.length;
        }
        rows.push(cols);
      }
      return { headers, rows };
    }


    function handleImportTradingViewCsv(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const text = e.target.result;
          const { headers, rows } = parseCsvText(text);
          if (!headers.length || !rows.length) {
            alert("No rows found in CSV.");
            return;
          }

          const lowerHeaders = headers.map(h => h.toLowerCase());

          function idxContains(substr) {
            const s = substr.toLowerCase();
            return lowerHeaders.findIndex(h => h.includes(s));
          }

          const idxSymbol     = idxContains("symbol");
          const idxSide       = idxContains("side");
          const idxQty        = idxContains("qty") >= 0 ? idxContains("qty") : idxContains("size");
          const idxFillPrice  = idxContains("fill price");
          let idxEntry        = -1;
          if (idxContains("entry price") >= 0) {
            idxEntry = idxContains("entry price");
          } else if (idxContains("open price") >= 0) {
            idxEntry = idxContains("open price");
          } else if (idxFillPrice >= 0) {
            idxEntry = idxFillPrice;
          } else {
            idxEntry = idxContains("price");
          }
          const idxSl         = idxContains("stop") >= 0 ? idxContains("stop") : idxContains("sl");
          const idxTp         = idxContains("take profit") >= 0 ? idxContains("take profit") : idxContains("tp");
          const idxPnl        = idxContains("net profit") >= 0 ? idxContains("net profit")
                                : (idxContains("profit") >= 0 ? idxContains("profit") : idxContains("p&l"));
          const idxClose      = idxContains("close time") >= 0 ? idxContains("close time")
                                : (idxContains("closed at") >= 0 ? idxContains("closed at") : idxContains("time"));
          const idxType       = idxContains("type");
          const idxPlacing    = idxContains("placing time");
          const idxCommission = idxContains("commission");
          const idxLeverage   = idxContains("leverage");
          const idxMargin     = idxContains("margin");
          const idxAction     = idxContains("action");

          const imported = [];

          rows.forEach(cols => {
            let symbol   = idxSymbol >= 0 ? cols[idxSymbol] : "";
            const sideRaw  = idxSide   >= 0 ? cols[idxSide]   : "";
            const qtyRaw   = idxQty    >= 0 ? cols[idxQty]    : "";
            const entryRaw = idxEntry  >= 0 ? cols[idxEntry]  : "";
            const slRaw    = idxSl     >= 0 ? cols[idxSl]     : "";
            const tpRaw    = idxTp     >= 0 ? cols[idxTp]     : "";
            const pnlRaw   = idxPnl    >= 0 ? cols[idxPnl]    : "";
            const closeRaw = idxClose  >= 0 ? cols[idxClose]  : "";
            const typeRaw  = idxType       >= 0 ? cols[idxType]       : "";
            const placingRaw = idxPlacing  >= 0 ? cols[idxPlacing]    : "";
            const commRaw    = idxCommission >= 0 ? cols[idxCommission] : "";
            const levRaw     = idxLeverage   >= 0 ? cols[idxLeverage]   : "";
            const marginRaw  = idxMargin     >= 0 ? cols[idxMargin]     : "";
            const actionRaw  = idxAction     >= 0 ? cols[idxAction]     : "";

            // For balance-history exports there may be no Symbol/Side columns; try to parse from Action text.
            let parsedSymbol = null;
            let parsedDirection = null;
            let parsedQty = null;
            if (actionRaw && actionRaw.length) {
              const lower = actionRaw.toLowerCase();
              if (lower.includes("close long position")) {
                parsedDirection = "Long";
              } else if (lower.includes("close short position")) {
                parsedDirection = "Short";
              }

              const symMarker = "symbol ";
              const atPriceMarker = " at price ";
              const iSym = actionRaw.indexOf(symMarker);
              const iPrice = actionRaw.indexOf(atPriceMarker);
              if (iSym >= 0 && iPrice > iSym) {
                parsedSymbol = actionRaw.substring(iSym + symMarker.length, iPrice).trim();
              }

              const forMarker = " for ";
              const unitsMarker = " units";
              const iFor = actionRaw.indexOf(forMarker);
              const iUnits = actionRaw.indexOf(unitsMarker, iFor + forMarker.length);
              if (iFor >= 0 && iUnits > iFor) {
                const qtyStr = actionRaw.substring(iFor + forMarker.length, iUnits).trim();
                const qn = parseFloat(qtyStr.replace(/[^0-9\.]/g, ""));
                if (isFinite(qn) && qn > 0) parsedQty = qn;
              }
            }

            if (!symbol && parsedSymbol) {
              symbol = parsedSymbol;
            }

            let direction = null;
            const sideLower = (sideRaw || "").toLowerCase();
            if (sideLower.includes("buy") || sideLower.includes("long")) {
              direction = "Long";
            } else if (sideLower.includes("sell") || sideLower.includes("short")) {
              direction = "Short";
            }
            if (!direction && parsedDirection) {
              direction = parsedDirection;
            }

            let contracts = null;
            const qtyNum = parseFloat(qtyRaw);
            if (isFinite(qtyNum) && qtyNum > 0) {
              contracts = qtyNum;
            } else if (parsedQty != null) {
              contracts = parsedQty;
            }

            // Prefer explicit entry/open/fill price; fall back gracefully.
            let entry = entryRaw || null;
            if (!entry && idxFillPrice >= 0) {
              const fp = cols[idxFillPrice];
              if (fp && fp.length) entry = fp;
            }

            const sl  = slRaw || null;
            const tp1 = tpRaw || null;

            let pnl = null;
            const pnlNum = parseFloat((pnlRaw || "").replace(/[^0-9\-\.]/g, ""));
            if (isFinite(pnlNum)) {
              pnl = pnlNum;
            }

            let result = null;
            if (pnl != null) {
              if (pnl > 0) result = "Win";
              else if (pnl < 0) result = "Loss";
              else result = "Breakeven";
            } else {
              result = "Pending";
            }

            let timestamp = null;
            if (closeRaw) {
              const d = new Date(closeRaw);
              if (!isNaN(d.getTime())) {
                timestamp = d.toISOString();
              }
            }
            if (!timestamp && headers.some(h => h.toLowerCase().includes("time"))) {
              const idxAnyTime = lowerHeaders.findIndex(h => h.includes("time"));
              if (idxAnyTime >= 0) {
                const raw = cols[idxAnyTime];
                if (raw) {
                  const d2 = new Date(raw);
                  if (!isNaN(d2.getTime())) {
                    timestamp = d2.toISOString();
                  }
                }
              }
            }
            if (!timestamp) {
              timestamp = new Date().toISOString();
            }

            // Try to map symbol (from column or Action) to a configured instrument ID
            let instrumentId = null;
            const instruments = settings.instruments || [];
            if (symbol && instruments.length) {
              const upperSym = symbol.toUpperCase();
              const afterColon = symbol.includes(":") ? symbol.split(":").pop() : symbol;
              const upperAfter = afterColon.toUpperCase();

              let inst = instruments.find(i => i.id && upperAfter === i.id.toUpperCase());
              if (!inst) {
                inst = instruments.find(i =>
                  i.id &&
                  (upperAfter.startsWith(i.id.toUpperCase()) || upperAfter.includes(i.id.toUpperCase()))
                );
              }
              if (!inst) {
                inst = instruments.find(i =>
                  i.id && upperSym.includes(i.id.toUpperCase())
                );
              }
              if (inst) {
                instrumentId = inst.id;
              }
            }

            let commission = null;
            const commNum = parseFloat((commRaw || "").replace(/[^0-9\-\.]/g, ""));
            if (isFinite(commNum)) {
              commission = commNum;
            }

            let tvMeta = [];
            if (typeRaw)    tvMeta.push("Type=" + typeRaw);
            if (placingRaw) tvMeta.push("Placed=" + placingRaw);
            if (closeRaw)   tvMeta.push("Closed=" + closeRaw);
            if (commRaw)    tvMeta.push("Commission=" + commRaw);
            if (levRaw)     tvMeta.push("Leverage=" + levRaw);
            if (marginRaw)  tvMeta.push("Margin=" + marginRaw);
            if (actionRaw)  tvMeta.push("Action=" + actionRaw);
            const metaNote = tvMeta.length
              ? ("Imported from TradingView CSV (" + tvMeta.join(" | ") + ")")
              : "Imported from TradingView CSV";

            // If absolutely nothing meaningful, skip
            if (!symbol && !pnl && !direction && !contracts) {
              return;
            }

            const trade = {
              id: Date.now() + Math.floor(Math.random() * 1000000),
              timestamp,
              symbol: symbol || null,
              direction,
              instrumentId: instrumentId,
              contracts: contracts || 1,
              entry,
              sl,
              tp1,
              tp2: null,
              result,
              rMultiple: null,
              pnl,
              pnlSource: (pnl != null ? "import" : null),
              commission,
              commissionSource: (commission != null ? "import" : null),
              notes: metaNote,
              tags: ["TV Import"],
              checklistPassed: null,
              failReason: null
            };

            imported.push(trade);
          });

          if (!imported.length) {
            alert("No usable rows found in TradingView CSV.");
            return;
          }

          tradeHistory = mergeTradeArrays(tradeHistory, imported);
          tradeHistory.sort((a, b) => {
            const ta = new Date(a.timestamp || 0).getTime();
            const tb = new Date(b.timestamp || 0).getTime();
            return tb - ta;
          });
          if (tradeHistory.length > 500) {
            tradeHistory = tradeHistory.slice(0, 500);
          }
          saveTradeHistory();
          renderTradeHistory();
          alert("Imported " + imported.length + " trades from TradingView CSV.");
        } catch (err) {
          console.error(err);
          alert("Failed to parse TradingView CSV file.");
        }
      };
      reader.readAsText(file);
    }

function computeStats(scope) {
      // Completed trades only (exclude Pending/Cancelled)
      let tradesForStats = tradeHistory.filter(t =>
        t &&
        t.timestamp &&
        t.result &&
        t.result !== "Cancelled" &&
        t.result !== "Pending"
      );

      if (!tradesForStats.length) {
        return null;
      }

      if (scope === "today") {
        const todayStr = new Date().toDateString();
        tradesForStats = tradesForStats.filter(t => {
          const d = new Date(t.timestamp || 0);
          return d.toDateString() === todayStr;
        });
      }

      if (!tradesForStats.length) {
        return null;
      }

      let wins = 0;
      let losses = 0;
      let breakevens = 0;
      let totalCount = 0;

      let netDollar = 0;
      let maxDD = 0;
      let eq = 0;
      let peak = 0;
      let pnlTradesCount = 0;

      const sorted = tradesForStats.slice().sort((a, b) => {
        const ta = new Date(a.timestamp || 0).getTime();
        const tb = new Date(b.timestamp || 0).getTime();
        return ta - tb;
      });

      sorted.forEach(t => {
        if (t.result === "Win") wins++;
        else if (t.result === "Loss") losses++;
        else if (t.result === "Breakeven") breakevens++;

        totalCount++;

        let pnl = null;
        if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") {
          const parsed = parseFloat(t.pnl);
          if (isFinite(parsed)) {
            pnl = parsed;
          }
        }

        if (pnl !== null) {
          pnlTradesCount++;
          eq += pnl;
          if (eq > peak) peak = eq;
          const dd = peak - eq;
          if (dd > maxDD) maxDD = dd;
          netDollar += pnl;
        }
      });

      const winRate = totalCount ? (wins / totalCount) * 100 : 0;

      return {
        count: totalCount,
        wins,
        losses,
        breakevens,
        winRate,
        netDollar,
        maxDD,
        pnlTradesCount
      };
    }

    function renderStats() {
      const container = document.getElementById("statsContainer");
      if (!container) return;

      const scopeLabel = statsScope === "today" ? "Today" : "All-time";

      if (!tradeHistory.length) {
        container.innerHTML = `
          <div class="history-header">
            <span>Session PnL & Drawdown</span>
            <div class="history-header-buttons">
              <button class="secondary small" type="button" onclick="toggleSettings()">Settings</button>
              <button class="secondary small" type="button" id="pnlToggleBtn">Hide PnL</button>
              <div class="scope-toggle">
                <button class="secondary small ${statsScope === "today" ? "active" : ""}" type="button" onclick="setStatsScope('today')">Today</button>
                <button class="secondary small ${statsScope === "all" ? "active" : ""}" type="button" onclick="setStatsScope('all')">All-time</button>
              </div>
            </div>
          </div>
          <div id="statsBody" class="stats-body">
            <div class="tip" style="margin-top:0.25rem;font-size:0.75rem;">
              No completed trades yet. As you log trades (and optionally fill PnL in dollars), this will show net PnL, win rate, and max drawdown.
            </div>
          </div>
        `;
        const toggleBtn = document.getElementById("pnlToggleBtn");
        if (toggleBtn) {
          toggleBtn.addEventListener("click", togglePnlVisibility);
        }
        applyPnlBlurState();
        return;
      }

      const stats = computeStats(statsScope);

      if (!stats) {
        container.innerHTML = `
          <div class="history-header">
            <span>Session PnL & Drawdown</span>
            <div class="history-header-buttons">
              <button class="secondary small" type="button" onclick="toggleSettings()">Settings</button>
              <button class="secondary small" type="button" id="pnlToggleBtn">Hide PnL</button>
              <div class="scope-toggle">
                <button class="secondary small ${statsScope === "today" ? "active" : ""}" type="button" onclick="setStatsScope('today')">Today</button>
                <button class="secondary small ${statsScope === "all" ? "active" : ""}" type="button" onclick="setStatsScope('all')">All-time</button>
              </div>
            </div>
          </div>
          <div id="statsBody" class="stats-body">
            <div class="tip" style="margin-top:0.25rem;font-size:0.75rem;">
              No completed trades for <strong>${scopeLabel}</strong> yet.
            </div>
          </div>
        `;
        const toggleBtn = document.getElementById("pnlToggleBtn");
        if (toggleBtn) {
          toggleBtn.addEventListener("click", togglePnlVisibility);
        }
        applyPnlBlurState();
        return;
      }

      // If no PnL numbers yet, show win-rate-only message
      if (!stats.pnlTradesCount) {
        container.innerHTML = `
          <div class="history-header">
            <span>Session PnL & Drawdown · <span style="color:#9ca3af;font-size:0.75rem;">${scopeLabel}</span></span>
            <div class="history-header-buttons">
              <button class="secondary small" type="button" onclick="toggleSettings()">Settings</button>
              <button class="secondary small" type="button" id="pnlToggleBtn">Hide PnL</button>
              <div class="scope-toggle">
                <button class="secondary small ${statsScope === "today" ? "active" : ""}" type="button" onclick="setStatsScope('today')">Today</button>
                <button class="secondary small ${statsScope === "all" ? "active" : ""}" type="button" onclick="setStatsScope('all')">All-time</button>
              </div>
            </div>
          </div>
          <div id="statsBody" class="stats-body">
            <div class="tip" style="margin-top:0.25rem;font-size:0.75rem;">
              Completed trades: ${stats.count} (Wins: ${stats.wins}, Losses: ${stats.losses}, Breakeven: ${stats.breakevens}).
              No PnL values recorded yet for this scope. Edit trades to add PnL ($) if you want equity and drawdown tracking.
            </div>
            <div class="stats-metrics" style="margin-top:0.5rem;">
              <div class="stats-metric">
                <div class="label">Win Rate</div>
                <div class="value">${stats.winRate.toFixed(0)}%</div>
                <div class="sub">${stats.wins}/${stats.count} wins</div>
              </div>
            </div>
          </div>
        `;
        const toggleBtn = document.getElementById("pnlToggleBtn");
        if (toggleBtn) {
          toggleBtn.addEventListener("click", togglePnlVisibility);
        }
        applyPnlBlurState();
        return;
      }

      const netDollar = stats.netDollar;
      const maxDD = stats.maxDD;
      const winRateStr = stats.winRate.toFixed(0);
      const netDollarStr =
        (netDollar >= 0 ? "+" : "") + netDollar.toFixed(2);
      const ddDollarStr = "-" + Math.abs(maxDD).toFixed(2);

      const magnitude = Math.min(Math.abs(netDollar), 1000); // visual cap at +/- $1000
      const pct = (magnitude / 1000) * 100;
      const barClass = netDollar >= 0 ? "positive" : "negative";

      container.innerHTML = `
        <div class="history-header">
          <span>Session PnL & Drawdown · <span style="color:#9ca3af;font-size:0.75rem;">${scopeLabel}</span></span>
          <div class="history-header-buttons">
            <button class="secondary small" type="button" onclick="toggleSettings()">Settings</button>
            <button class="secondary small" type="button" id="pnlToggleBtn">Hide PnL</button>
            <div class="scope-toggle">
              <button class="secondary small ${statsScope === "today" ? "active" : ""}" type="button" onclick="setStatsScope('today')">Today</button>
              <button class="secondary small ${statsScope === "all" ? "active" : ""}" type="button" onclick="setStatsScope('all')">All-time</button>
            </div>
          </div>
        </div>
        <div id="statsBody" class="stats-body">
          <div class="stats-bar-bg">
            <div class="stats-bar-fill ${barClass}" style="width:${pct}%;"></div>
          </div>
          <div class="stats-metrics">
            <div class="stats-metric">
              <div class="label">Net PnL</div>
              <div class="value">${netDollarStr}$</div>
              <div class="sub">${stats.pnlTradesCount} trades with PnL</div>
            </div>
            <div class="stats-metric">
              <div class="label">Max Drawdown</div>
              <div class="value">${ddDollarStr}$</div>
              <div class="sub">From running equity</div>
            </div>
            <div class="stats-metric">
              <div class="label">Win Rate</div>
              <div class="value">${winRateStr}%</div>
              <div class="sub">${stats.wins}/${stats.count} wins</div>
            </div>
          </div>
        </div>
      `;

      const toggleBtn = document.getElementById("pnlToggleBtn");
      if (toggleBtn) {
        toggleBtn.addEventListener("click", togglePnlVisibility);
      }
      applyPnlBlurState();
    }

    function getInstrumentOptionsHtml(selectedId) {
      const instruments = settings.instruments || [];
      if (!instruments.length) {
        return '<option value="">No instruments configured</option>';
      }
      let html = '<option value="">Select…</option>';
      instruments.forEach(inst => {
        const sel = inst.id === selectedId ? " selected" : "";
        html += `<option value="${inst.id}"${sel}>${inst.label || inst.id}</option>`;
      });
      return html;
    }

    
    function getInstrumentLabelById(id) {
      const instruments = settings.instruments || [];
      const inst = instruments.find(i => String(i.id) === String(id));
      return inst ? (inst.label || inst.id) : "";
    }

function renderInstrumentSettings() {
      const container = document.getElementById("instrumentSettings");
      if (!container) return;
      const instruments = settings.instruments || [];

      let rowsHtml = "";
      instruments.forEach((inst, idx) => {
        rowsHtml += `
          <div class="journal-grid" data-index="${idx}" style="margin-bottom:0.5rem;">
            <div>
              <label>Symbol ID</label>
              <input type="text" class="inst-id" value="${inst.id || ""}" />
            </div>
            <div>
              <label>Label</label>
              <input type="text" class="inst-label" value="${inst.label || ""}" />
            </div>
            <div>
              <label>Tick Size</label>
              <input type="number" step="0.01" class="inst-ticksize" value="${inst.tickSize != null ? inst.tickSize : ""}" />
            </div>
            <div>
              <label>Tick Value ($)</label>
              <input type="number" step="0.01" class="inst-tickvalue" value="${inst.tickValue != null ? inst.tickValue : ""}" />
            </div>
            <div>
              <label>Commission ($/contract RT)</label>
              <input type="number" step="0.01" class="inst-commission" value="${inst.commissionPerContract != null ? inst.commissionPerContract : ""}" />
            </div>
          </div>
        `;
      });

      container.innerHTML = `
        <div class="history-header">
          <span>Instrument Settings</span>
          <div class="history-header-buttons">
            <button class="secondary small" type="button" id="addInstrumentBtn">Add</button>
            <button class="secondary small" type="button" id="saveInstrumentBtn">Save</button>
          </div>
        </div>
        <div style="font-size:0.75rem;color:#9ca3af;margin-bottom:0.5rem;">
          Configure the futures you trade. Symbol ID is used internally (e.g. MES, MNQ).
          Tick size is the minimum price increment; tick value is dollar value per tick per contract. Commission is optional and is treated as a per-contract round-trip cost for auto PnL.
        </div>
        <div id="instrumentRows">
          ${rowsHtml || "<div class='tip' style='font-size:0.75rem;'>No instruments yet. Click Add to create one.</div>"}
        </div>
      `;

      const addBtn = document.getElementById("addInstrumentBtn");
      const saveBtn = document.getElementById("saveInstrumentBtn");
      if (addBtn) addBtn.addEventListener("click", () => {
        const instruments = settings.instruments || [];
        instruments.push({ id: "", label: "", tickSize: "", tickValue: "", commissionPerContract: 0 });
        settings.instruments = instruments;
        renderInstrumentSettings();
      });
      if (saveBtn) saveBtn.addEventListener("click", saveInstrumentsFromDOM);;
    }

    function toggleSettings() {
      const container = document.getElementById("instrumentSettings");
      if (!container) return;
      const isHidden = container.style.display === "none" || container.style.display === "";
      if (isHidden) {
        container.style.display = "block";
        renderInstrumentSettings();
        settingsPanelOpen = true;
        setTimeout(() => {
          document.addEventListener("mousedown", handleSettingsOutsideClick, true);
        }, 0);
      } else {
        container.style.display = "none";
        settingsPanelOpen = false;
        document.removeEventListener("mousedown", handleSettingsOutsideClick, true);
      }
    }

    
    function closeAllPopups() {
      // Close trade details / edit panel
      viewingTradeId = null;
      editingTradeId = null;
      const edit = document.getElementById("editContainer");
      if (edit) {
        edit.style.display = "none";
        edit.innerHTML = "";
      }

      // Close instrument settings panel (and outside click listener)
      const settingsPanel = document.getElementById("instrumentSettings");
      if (settingsPanel) {
        settingsPanel.style.display = "none";
      }
      settingsPanelOpen = false;
      try {
        document.removeEventListener("mousedown", handleSettingsOutsideClick, true);

      // Post-load migrations (keeps older JSON compatible with new fields)
      tradeHistory = upgradeTradesArray(tradeHistory);
      (tradeHistory || []).forEach(t => {
        if (!t || typeof t !== "object") return;

        // Default pnlSource for older trades: assume manual if a PnL exists.
        if (t.pnlSource === undefined || t.pnlSource === null || t.pnlSource === "") {
          if (t.pnl !== null && t.pnl !== undefined && t.pnl !== "") t.pnlSource = "manual";
        }

        // Fill commission from instrument settings if missing (does NOT change PnL).
        if ((t.commission === undefined || t.commission === null || t.commission === "") &&
            t.instrumentId && t.commissionSource !== "import") {
          const qty = t.contracts || 1;
          const c = computeDefaultCommission(t.instrumentId, qty);
          if (isFinite(c)) {
            t.commission = c;
            t.commissionSource = "instrument";
          }
        }
      });

      } catch (e) {}
    }

function saveInstrumentsFromDOM() {
      const container = document.getElementById("instrumentRows");
      if (!container) return;
      const grids = container.querySelectorAll(".journal-grid[data-index]");
      const newInstruments = [];
      grids.forEach(grid => {
        const idInput = grid.querySelector(".inst-id");
        const labelInput = grid.querySelector(".inst-label");
        const sizeInput = grid.querySelector(".inst-ticksize");
        const valueInput = grid.querySelector(".inst-tickvalue");
        const commInput = grid.querySelector(".inst-commission");
        const id = idInput && idInput.value ? idInput.value.trim() : "";
        const label = labelInput && labelInput.value ? labelInput.value.trim() : "";
        const tickSizeVal = sizeInput && sizeInput.value !== "" ? parseFloat(sizeInput.value) : null;
        const tickValueVal = valueInput && valueInput.value !== "" ? parseFloat(valueInput.value) : null;
        const commVal = commInput && commInput.value !== "" ? parseFloat(commInput.value) : null;
        if (!id) return;
        newInstruments.push({
          id,
          label: label || id,
          tickSize: tickSizeVal,
          tickValue: tickValueVal,
          commissionPerContract: (commVal != null && isFinite(commVal) ? commVal : 0)
        });
      });
      settings.instruments = newInstruments;
      if (newInstruments.length && !settings.lastInstrumentId) {
        settings.lastInstrumentId = newInstruments[0].id;
      }
      saveSettings();
      renderInstrumentSettings();
      alert("Instruments saved.");
      const panel = document.getElementById("instrumentSettings");
      if (panel) {
        panel.style.display = "none";
      }
      settingsPanelOpen = false;
      document.removeEventListener("mousedown", handleSettingsOutsideClick, true);
    }

    function computeDefaultCommission(instrumentId, contracts) {
      const instruments = settings.instruments || [];
      const inst = instruments.find(i => i.id === instrumentId);
      if (!inst) return 0;
      const commPer = parseFloat(inst.commissionPerContract);
      const qty = parseFloat(contracts || 1) || 1;
      if (!isFinite(commPer) || commPer <= 0 || !isFinite(qty) || qty <= 0) return 0;
      return commPer * qty;
    }

    function computeAutoPnLDetail(params) {
      const { instrumentId, direction, entry, sl, tp1, result, contracts } = params;
      const instruments = settings.instruments || [];
      const inst = instruments.find(i => i.id === instrumentId);
      if (!inst) return null;

      const tickSize = parseFloat(inst.tickSize);
      const tickValue = parseFloat(inst.tickValue);
      if (!isFinite(tickSize) || tickSize <= 0 || !isFinite(tickValue) || tickValue <= 0) return null;

      const e = parseFloat(entry);
      const s = parseFloat(sl);
      const t1 = parseFloat(tp1);
      const qty = parseFloat(contracts || 1) || 1;
      if (!isFinite(e) || !isFinite(s) || !isFinite(t1) || !isFinite(qty) || qty <= 0) return null;

      const commission = computeDefaultCommission(instrumentId, qty);

      if (result === "Breakeven") {
        // Treat breakeven as flat on price, but still pay commission if configured.
        return { pnl: -commission, commission };
      }

      let priceDiff;
      if (result === "Win") {
        if (direction === "Long") priceDiff = t1 - e;
        else if (direction === "Short") priceDiff = e - t1;
        else return null;
      } else if (result === "Loss") {
        if (direction === "Long") priceDiff = s - e;
        else if (direction === "Short") priceDiff = e - s;
        else return null;
      } else {
        return null;
      }

      const ticks = priceDiff / tickSize;
      const pnlPerContract = ticks * tickValue;
      const totalGross = pnlPerContract * qty;
      if (!isFinite(totalGross)) return null;

      const net = totalGross - commission;
      return { pnl: net, commission };
    }

    function computeAutoPnL(params) {
      const detail = computeAutoPnLDetail(params);
      return detail ? detail.pnl : null;
    }

    function computeChecklistScore(questionsArr, answersArr) {
      if (!Array.isArray(questionsArr) || questionsArr.length === 0) return null;
      let correct = 0;
      const total = questionsArr.length;
      for (let i = 0; i < total; i++) {
        const q = questionsArr[i] || {};
        const failOn = (q.failOn === "yes" || q.failOn === "no") ? q.failOn : "no";
        const ans = answersArr && (answersArr[i] === "yes" || answersArr[i] === "no") ? answersArr[i] : null;
        if (ans !== null && ans !== failOn) {
          correct++;
        }
      }
      const pct = Math.round((correct / total) * 100);
      return isFinite(pct) ? pct : null;
    }


    function escapeHtml(str) {
      if (str === null || str === undefined) return "";
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function buildChecklistSnapshot(questionsArr, answersArr) {
      if (!Array.isArray(questionsArr) || questionsArr.length === 0) return null;
      const snap = [];
      for (let i = 0; i < questionsArr.length; i++) {
        const q = questionsArr[i] || {};
        const failOn = (q.failOn === "yes" || q.failOn === "no") ? q.failOn : "no";
        const ans = answersArr && (answersArr[i] === "yes" || answersArr[i] === "no") ? answersArr[i] : null;
        snap.push({
          idx: i + 1,
          id: q.id != null ? q.id : (i + 1),
          section: typeof q.section === "string" ? q.section : "",
          text: typeof q.text === "string" ? q.text : "",
          hardStop: !!q.hardStop,
          failOn,
          answer: ans
        });
      }
      return snap;
    }

    function buildChecklistReviewHtml(trade) {
      if (!trade) return "";

      const name = trade.checklistName || trade.checklistKey || null;
      const score = (trade.checklistScore !== null && trade.checklistScore !== undefined && trade.checklistScore !== "")
        ? Math.round(parseFloat(trade.checklistScore))
        : null;

      const status =
        trade.checklistPassed === true ? "Passed" :
        trade.checklistPassed === false ? "Blocked" :
        trade.checklistKey ? "Logged" : "Not used";

      const scoreBadge = (score !== null && isFinite(score))
        ? `<span class="badge badge-grade">${score}%</span>`
        : "";

      let inner = `<div><strong>Checklist:</strong> ${name ? escapeHtml(name) : "—"} ${scoreBadge} <span style="color:#6b7280;">(${status})</span></div>`;

      const snap = Array.isArray(trade.checklistSnapshot) ? trade.checklistSnapshot : null;

      if (snap && snap.length) {
        const failed = snap.filter(it => {
          const ans = (it.answer === "yes" || it.answer === "no") ? it.answer : null;
          const failOn = (it.failOn === "yes" || it.failOn === "no") ? it.failOn : "no";
          return ans === null || ans === failOn;
        });

        if (!failed.length) {
          inner += `<div class="ok" style="margin-top:0.35rem;">No failed items.</div>`;
        } else {
          const unansweredCount = failed.filter(it => it.answer === null).length;
          const answeredFailCount = failed.length - unansweredCount;

          inner += `<div style="margin-top:0.35rem;"><strong>Missed items:</strong> ${failed.length} <span style="color:#6b7280;">(${answeredFailCount} failed, ${unansweredCount} unanswered)</span></div>`;
          inner += `<ul>`;
          failed.forEach(it => {
            const ans = (it.answer === "yes" || it.answer === "no") ? it.answer : null;
            const label = ans === null ? `<span class="warn">Unanswered</span>` : `<span class="fail">Answered ${ans.toUpperCase()}</span>`;
            const sec = it.section ? `${escapeHtml(it.section)} — ` : "";
            const txt = it.text ? escapeHtml(it.text) : "(missing question text)";
            inner += `<li>${label}: ${sec}${txt}</li>`;
          });
          inner += `</ul>`;
        }
      } else if (trade.failReason) {
        inner += `<div class="warn" style="margin-top:0.35rem;"><strong>Blocked on:</strong> ${escapeHtml(trade.failReason)}</div>`;
        inner += `<div style="margin-top:0.25rem;color:#6b7280;">(No checklist snapshot was saved for this trade.)</div>`;
      } else if (trade.checklistKey || trade.checklistName || trade.checklistScore !== null) {
        inner += `<div style="margin-top:0.35rem;color:#6b7280;">No checklist snapshot stored for this trade.</div>`;
      } else {
        return "";
      }

      return `<div class="checklist-review">${inner}</div>`;
    }

    function renderTradeHistory() {
      const container = document.getElementById("historyContainer");
      if (!container) return;

      if (!tradeHistory.length) {
        container.innerHTML = `
          <div class="history-header">
            <span>Trade History (local)</span>
            <div class="history-header-buttons">
              <span style="font-size:0.7rem;color:#9ca3af;margin-right:0.25rem;">Export:</span>
              <button class="secondary small" type="button" onclick="exportHistoryCSV()">CSV</button>
              <button class="secondary small" type="button" onclick="exportHistoryJSON()">JSON</button>
              <span style="font-size:0.7rem;color:#9ca3af;margin:0 0.25rem 0 0.5rem;">Import:</span>
              <button class="secondary small" type="button" onclick="triggerImportTvCsv()">TV CSV</button>
              <button class="secondary small" type="button" onclick="triggerImport()">JSON</button>
            </div>
          </div>
          <div class="tip" style="margin-top:0.25rem;">
            After completing the checklist, log your trade to build statistics over time.
          </div>
        `;
        renderStats();
        return;
      }


      // Make sure every trade has a stable id / timestamp / updatedAt (migration).
      let mutated = false;
      tradeHistory.forEach(t => {
        const hadId = !!(t && t.id);
        const hadTs = !!(t && t.timestamp);
        const hadUp = !!(t && t.updatedAt);
        ensureTradeMeta(t);
        if (!hadId || !hadTs || !hadUp) mutated = true;
      });

      // Display-only numbering (deterministic): oldest trade = Trade 1.
      const tradeNumberMap = computeTradeNumberMap(tradeHistory);

      let inner = `
        <div class="history-header">
          <span>Trade History (local)</span>
          <div class="history-header-buttons">
            <span style="font-size:0.7rem;color:#9ca3af;margin-right:0.25rem;">Export:</span>
            <button class="secondary small" type="button" onclick="exportHistoryCSV()">CSV</button>
            <button class="secondary small" type="button" onclick="exportHistoryJSON()">JSON</button>
            <span style="font-size:0.7rem;color:#9ca3af;margin:0 0.25rem 0 0.5rem;">Import:</span>
            <button class="secondary small" type="button" onclick="triggerImportTvCsv()">TV CSV</button>
            <button class="secondary small" type="button" onclick="triggerImport()">JSON</button>
            <button class="secondary small" type="button" onclick="clearTradeHistory()">Clear</button>
          </div>
        </div>
      `;

      // Display newest trade first based on the trade timestamp (the date/time you input),
      // not the time you clicked "Save".
      const tradeTimeValue = tradeTimeValueGlobal;

      const tradesSorted = [...tradeHistory].sort((a, b) => tradeTimeValue(b) - tradeTimeValue(a));

      tradesSorted.forEach(trade => {
        let cls = "";
        const status = trade.checklistPassed;
        if (status === false) {
          cls = "blocked";
        } else if (trade.result === "Win") {
          cls = "win";
        } else if (trade.result === "Loss") {
          cls = "loss";
        }

        const dateStr = trade.timestamp ? new Date(trade.timestamp).toLocaleString() : "";
        let resultLabel;
        if (trade.result) {
          resultLabel = trade.result;
        } else if (status === true) {
          resultLabel = "Pending";
        } else if (status === false) {
          resultLabel = "Blocked";
        } else {
          resultLabel = "Logged";
        }

        let badgeClass = "badge-pending";
        if (status === false) {
          badgeClass = "badge-fail";
        } else if (trade.result === "Win") {
          badgeClass = "badge-pass";
        } else if (trade.result === "Loss") {
          badgeClass = "badge-fail";
        }

        

        let gradeHtml = "";
        if (trade.checklistScore !== null && trade.checklistScore !== undefined && trade.checklistScore !== "") {
          const g = parseFloat(trade.checklistScore);
          if (isFinite(g)) gradeHtml = `<span class="badge badge-grade">${Math.round(g)}%</span>`;
        }

        ensureTradeMeta(trade);
        const id = String(trade.id);
        const tradeNum = tradeNumberMap.get(id) || "";

        const tagsPills = (Array.isArray(trade.tags) && trade.tags.length)
          ? trade.tags.map(t => `<span class="tag-pill">${escapeHtml(t)}</span>`).join("")
          : "";
        const tagsHtml = `<div class="tags-line"><div class="tags-wrap">${tagsPills}</div><span class="trade-num">Trade ${tradeNum}</span></div>`;

        let pnlHtml = "";
        if (trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== "") {
          const p = parseFloat(trade.pnl);
          if (isFinite(p)) {
            const sign = p >= 0 ? "+" : "";
            pnlHtml = ` | PnL: ${sign}$${p.toFixed(2)}`;
          }
        }

        const instrumentLabel = trade.instrumentId
          ? (settings.instruments || []).find(i => i.id === trade.instrumentId)?.label || trade.instrumentId
          : "";

        const instPart = instrumentLabel ? ` · ${instrumentLabel}` : "";

        inner += `
          <div class="history-item ${cls}" onclick="openTradeDetails('${id}')">
            <div class="history-line1">
              <span><strong>${trade.symbol || "N/A"}</strong> · ${trade.direction || "?"}${instPart}</span>
              <span>${dateStr}</span>
            </div>
            <div class="history-line2">
              <span>Entry: ${trade.entry || "-"} | SL: ${trade.sl || "-"} | TP: ${trade.tp1 || "-"}${pnlHtml}</span>
              <span>
                <span class="badge ${badgeClass}">${resultLabel}</span>
                ${gradeHtml}
              </span>
            </div>
            ${trade.notes ? `<div style="margin-top:0.25rem;color:#9ca3af;">${trade.notes}</div>` : ""}
            ${tagsHtml}
            ${status === false && trade.failReason ? `<div style="margin-top:0.25rem;color:#f97316;font-size:0.75rem;">Blocked on: ${trade.failReason}</div>` : ""}
          </div>
        `;
      });

      container.innerHTML = inner;
      if (mutated) saveTradeHistory();
      renderStats();
    }

    
    function formatMoney(n) {
      const num = parseFloat(n);
      if (!isFinite(num)) return "-";
      const sign = num > 0 ? "+" : "";
      return sign + "$" + num.toFixed(2);
    }

    let viewingTradeId = null;

    function openTradeDetails(id) {
      const trade = tradeHistory.find(t => String(t.id) === String(id));
      if (!trade) return;

      viewingTradeId = trade.id;
      editingTradeId = null;

      const container = document.getElementById("editContainer");
      if (!container) return;

      const dateStr = trade.timestamp ? new Date(trade.timestamp).toLocaleString() : "";
      const instLabel = trade.instrumentId ? getInstrumentLabelById(trade.instrumentId) : "";
      const instLine = instLabel ? instLabel : (trade.instrumentId || "");

      const direction = trade.direction || "";
      const qty = trade.contracts || 1;

      const entry = trade.entry;
      const sl = trade.sl;
      const tp1 = trade.tp1;
      const tp2 = trade.tp2;

      const result = trade.result || (trade.checklistPassed === false ? "Blocked" : "Pending");

      // Auto PnL (only when Win/Loss/Breakeven and we have the needed fields)
      let autoDetail = null;
      if (trade.instrumentId && (result === "Win" || result === "Loss" || result === "Breakeven")) {
        autoDetail = computeAutoPnLDetail({
          instrumentId: trade.instrumentId,
          direction: direction,
          entry: entry,
          sl: sl,
          tp1: tp1,
          result: result,
          contracts: qty
        });
      }

      const score = (typeof trade.checklistScore === "number") ? trade.checklistScore : null;
      const scoreBadge = score != null ? `<span class="badge badge-grade" style="margin-left:0.35rem;">${score}%</span>` : "";

      const checklistName = trade.checklistKey ? (settings.checklists || []).find(c => c.key === trade.checklistKey)?.name : "";
      const checklistStatus = trade.checklistPassed === true ? "Passed"
        : trade.checklistPassed === false ? "Failed/Blocked"
        : trade.checklistKey ? "Logged (no pass/fail)" : "Not used";

      const tagsHtml = Array.isArray(trade.tags) && trade.tags.length
        ? `<div class="tags-line">${trade.tags.map(t => `<span class="tag-pill">${escapeHtml(t)}</span>`).join("")}</div>`
        : `<div class="tip" style="margin-top:0.25rem;">No tags.</div>`;

      const notesHtml = trade.notes
        ? `<div style="margin-top:0.35rem;color:#9ca3af;white-space:pre-wrap;">${escapeHtml(trade.notes)}</div>`
        : `<div class="tip" style="margin-top:0.25rem;">No notes.</div>`;

      const idSafe = String(trade.id).replace(/'/g, "&#39;");

      container.style.display = "block";
      container.innerHTML = `
        <div class="history-header">
          <span>Trade Details</span>
          <div class="history-header-buttons">
            <button class="secondary small" type="button" onclick="startEditTrade('${idSafe}')">Edit Trade</button>
            <button class="secondary small" type="button" onclick="closeTradeDetails()">Close</button>
          </div>
        </div>

        <div class="tip" style="margin-top:0.25rem;">
          ${escapeHtml(dateStr)}
        </div>

        <div class="journal-grid" style="margin-top:0.75rem;">
          <div>
            <label>Instrument</label>
            <div style="font-size:0.9rem;">${escapeHtml(instLine || "-")}</div>
          </div>
          <div>
            <label>Direction</label>
            <div style="font-size:0.9rem;">${escapeHtml(direction || "-")}</div>
          </div>
          <div>
            <label>Contracts</label>
            <div style="font-size:0.9rem;">${escapeHtml(String(qty || 1))}</div>
          </div>
          <div>
            <label>Result</label>
            <div style="font-size:0.9rem;">${escapeHtml(result)} ${scoreBadge}</div>
          </div>
          <div>
            <label>Entry</label>
            <div style="font-size:0.9rem;">${escapeHtml(entry != null ? String(entry) : "-")}</div>
          </div>
          <div>
            <label>Stop</label>
            <div style="font-size:0.9rem;">${escapeHtml(sl != null ? String(sl) : "-")}</div>
          </div>
          <div>
            <label>TP1</label>
            <div style="font-size:0.9rem;">${escapeHtml(tp1 != null ? String(tp1) : "-")}</div>
          </div>
          <div>
            <label>TP2</label>
            <div style="font-size:0.9rem;">${escapeHtml(tp2 != null ? String(tp2) : "-")}</div>
          </div>
        </div>

        <div style="margin-top:0.75rem;">
          <div style="display:flex;justify-content:space-between;gap:0.75rem;align-items:center;">
            <div style="font-size:0.85rem;color:#9ca3af;">Auto PnL (net from Entry/SL/TP1 + Result${(autoDetail && isFinite(autoDetail.commission) && autoDetail.commission > 0) ? (' · Comm: $' + autoDetail.commission.toFixed(2)) : ''})</div>
            <div style="font-weight:600;">
              ${autoDetail == null ? "-" : formatMoney(autoDetail.pnl)}
            </div>
          </div>
        </div>

        <div style="margin-top:0.9rem;border-top:1px solid #111827;padding-top:0.75rem;">
          <div style="font-size:0.9rem;color:#e5e7eb;margin-bottom:0.35rem;">Checklist Review</div>
          <div class="tip" style="margin-top:0.15rem;">
            <strong>${escapeHtml(checklistName || "Checklist")}</strong> · ${escapeHtml(checklistStatus)}
          </div>
          ${buildChecklistReviewHtml(trade)}
        </div>

        <div style="margin-top:0.9rem;border-top:1px solid #111827;padding-top:0.75rem;">
          <div style="font-size:0.9rem;color:#e5e7eb;margin-bottom:0.25rem;">Tags</div>
          ${tagsHtml}
        </div>

        <div style="margin-top:0.9rem;border-top:1px solid #111827;padding-top:0.75rem;">
          <div style="font-size:0.9rem;color:#e5e7eb;margin-bottom:0.25rem;">Notes</div>
          ${notesHtml}
        </div>
      `;

      try { container.scrollIntoView({ behavior: "smooth", block: "start" }); } catch (e) {}
    }

    function closeTradeDetails() {
      viewingTradeId = null;
      const container = document.getElementById("editContainer");
      if (container) {
        container.style.display = "none";
        container.innerHTML = "";
      }
    }

function startEditTrade(id) {
      const trade = tradeHistory.find(t => String(t.id) === String(id));
      if (!trade) return;
      editingTradeId = trade.id;

      const container = document.getElementById("editContainer");
      if (!container) return;

      container.style.display = "block";
      const instrumentOptions = getInstrumentOptionsHtml(trade.instrumentId || settings.lastInstrumentId || "");
      const checklistReviewHtml = buildChecklistReviewHtml(trade);

      container.innerHTML = `
        <div class="history-header">
          <span>Edit Trade</span>
          <div class="history-header-buttons">
            <button class="secondary small" type="button" onclick="cancelEdit()">Close</button>
          </div>
        </div>
        <div class="journal-grid">
          <div>
            <label for="editSymbol">Symbol</label>
            <input id="editSymbol" type="text" />
          </div>
          <div>
            <label for="editDirection">Direction</label>
            <select id="editDirection">
              <option value="">Select…</option>
              <option value="Long">Long</option>
              <option value="Short">Short</option>
            </select>
          </div>
          <div>
            <label for="editInstrument">Instrument</label>
            <select id="editInstrument">
              ${instrumentOptions}
            </select>
          </div>
          <div>
            <label for="editContracts">Contracts</label>
            <input id="editContracts" type="number" min="1" step="1" />
          </div>
          <div>
            <label for="editEntry">Entry Price</label>
            <input id="editEntry" type="number" step="0.25" />
          </div>
          <div>
            <label for="editSL">Stop Loss</label>
            <input id="editSL" type="number" step="0.25" />
          </div>
          <div>
            <label for="editTP1">Take Profit 1</label>
            <input id="editTP1" type="number" step="0.25" />
          </div>
          <div>
            <label for="editTP2">Take Profit 2</label>
            <input id="editTP2" type="number" step="0.25" />
          </div>
          <div>
            <label for="editResult">Result</label>
            <select id="editResult">
              <option value="">(leave)</option>
              <option value="Pending">Pending</option>
              <option value="Win">Win</option>
              <option value="Loss">Loss</option>
              <option value="Breakeven">Breakeven</option>
              <option value="Cancelled">Cancelled</option>
            </select>
          </div>
          <div>
            <label for="editRMultiple">R-Multiple</label>
            <input id="editRMultiple" type="number" step="0.1" />
          </div>
        </div>
        <div>
          <label for="editPnL">Realized PnL ($, optional)</label>
          <input id="editPnL" type="number" step="0.01" />
          <div style="display:flex;gap:0.5rem;align-items:center;margin-top:0.35rem;">
            <div id="editAutoPnlPreview" class="tip" style="flex:1;margin:0;font-size:0.75rem;">Auto PnL (net, incl. comm): —</div>
            <button type="button" class="secondary small" id="editUseAutoBtn">Use Auto</button>
          </div>
        </div>
        <div>
          <label for="editTags">Tags (comma-separated)</label>
          <input id="editTags" type="text" />
        </div>
        <div>
          <label for="editNotes">Notes</label>
          <textarea id="editNotes" rows="2"></textarea>
        </div>
        ${checklistReviewHtml}
        <div class="journal-actions">
          <button type="button" class="primary" onclick="saveEditedTrade()">Save Changes</button>
          <button type="button" class="secondary" onclick="cancelEdit()">Cancel</button>
          <button type="button" class="danger" onclick="deleteEditedTrade()">Delete Trade</button>
        </div>
      `;

      const setVal = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.value = val != null ? val : "";
      };

      setVal("editSymbol", trade.symbol);
      setVal("editDirection", trade.direction);
      setVal("editInstrument", trade.instrumentId);
      setVal("editContracts", trade.contracts || 1);
      setVal("editEntry", trade.entry);
      setVal("editSL", trade.sl);
      setVal("editTP1", trade.tp1);
      setVal("editTP2", trade.tp2);
      setVal("editResult", trade.result);
      setVal("editRMultiple", trade.rMultiple);
      const tagsStr = Array.isArray(trade.tags) ? trade.tags.join(", ") : (trade.tags || "");
      setVal("editTags", tagsStr);
      setVal("editPnL", trade.pnl);
      setVal("editNotes", trade.notes);

      attachEditAutoPnlHandlers(trade);
    }


    function attachEditAutoPnlHandlers(trade) {
      const pnlEl = document.getElementById("editPnL");
      const previewEl = document.getElementById("editAutoPnlPreview");
      const useBtn = document.getElementById("editUseAutoBtn");

      if (!pnlEl || !previewEl) return;

      // Decide if this trade should be treated as auto or manual by default.
      // - Newer trades will have trade.pnlSource ("auto" or "manual")
      // - Older trades: if pnl exists, assume manual (don't overwrite unless user clears / clicks Use Auto)
      const initialSource = (trade && trade.pnlSource === "auto") ? "auto"
        : (!pnlEl.value ? "auto" : "manual");
      pnlEl.dataset.source = initialSource;

      const getVals = () => {
        const instrumentId = (document.getElementById("editInstrument") || {}).value || "";
        const direction = (document.getElementById("editDirection") || {}).value || "";
        const entry = (document.getElementById("editEntry") || {}).value || "";
        const sl = (document.getElementById("editSL") || {}).value || "";
        const tp1 = (document.getElementById("editTP1") || {}).value || "";
        const result = (document.getElementById("editResult") || {}).value || "";
        const contractsRaw = (document.getElementById("editContracts") || {}).value || "1";
        const contractsNum = parseFloat(contractsRaw);
        const contracts = isFinite(contractsNum) && contractsNum > 0 ? contractsNum : 1;
        return { instrumentId, direction, entry, sl, tp1, result, contracts };
      };

      const render = (detail) => {
        if (!detail) {
          previewEl.textContent = "Auto PnL (net, incl. comm): — (needs instrument + entry/SL/TP1 + result)";
          return;
        }
        const comm = (detail.commission && isFinite(detail.commission) && detail.commission > 0)
          ? ` (comm $${detail.commission.toFixed(2)})`
          : "";
        previewEl.textContent = `Auto PnL (net, incl. comm): ${formatMoney(detail.pnl)}${comm}`;
      };

      const recompute = (forceApply) => {
        const v = getVals();
        const okResult = (v.result === "Win" || v.result === "Loss" || v.result === "Breakeven");
        let detail = null;
        if (v.instrumentId && okResult && v.entry && v.sl && v.tp1 && v.direction) {
          detail = computeAutoPnLDetail(v);
        }
        render(detail);

        const allowAutoApply =
          forceApply ||
          pnlEl.dataset.source === "auto" ||
          pnlEl.value === "";

        if (detail && allowAutoApply) {
          pnlEl.value = isFinite(detail.pnl) ? detail.pnl.toFixed(2) : "";
          pnlEl.dataset.source = "auto";
        }
      };

      // If user types into PnL, treat it as manual. Clearing it re-enables auto.
      pnlEl.addEventListener("input", () => {
        pnlEl.dataset.source = (pnlEl.value === "") ? "auto" : "manual";
        recompute(false);
      });

      ["editInstrument","editDirection","editEntry","editSL","editTP1","editResult","editContracts"].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const evt = (el.tagName === "SELECT") ? "change" : "input";
        el.addEventListener(evt, () => recompute(false));
        if (el.tagName === "SELECT") el.addEventListener("input", () => recompute(false));
      });

      if (useBtn) {
        useBtn.addEventListener("click", () => recompute(true));
      }

      // Initial paint
      recompute(false);
    }

    function saveEditedTrade() {
      if (editingTradeId == null) return;
      const trade = tradeHistory.find(t => t.id === editingTradeId);
      if (!trade) return;

      const getVal = id => {
        const el = document.getElementById(id);
        return el ? el.value : "";
      };

      const symbol = getVal("editSymbol").trim();
      const direction = getVal("editDirection");
      const instrumentId = getVal("editInstrument");
      const contractsRaw = getVal("editContracts");
      const entry = getVal("editEntry");
      const sl = getVal("editSL");
      const tp1 = getVal("editTP1");
      const tp2 = getVal("editTP2");
      const result = getVal("editResult");
      const rMultiple = getVal("editRMultiple");
      const tagsRaw = getVal("editTags").trim();
      const pnlStr = getVal("editPnL");
      const notes = getVal("editNotes").trim();

      if (symbol) trade.symbol = symbol;
      if (direction) trade.direction = direction;
      if (instrumentId) trade.instrumentId = instrumentId;
      const contractsNum = contractsRaw ? parseFloat(contractsRaw) : null;
      trade.contracts = contractsNum && isFinite(contractsNum) && contractsNum > 0 ? contractsNum : null;

      trade.entry = entry || null;
      trade.sl = sl || null;
      trade.tp1 = tp1 || null;
      trade.tp2 = tp2 || null;
      if (result) trade.result = result;
      trade.rMultiple = rMultiple || null;

      if (tagsRaw) {
        trade.tags = tagsRaw.split(",").map(t => t.trim()).filter(Boolean);
      } else {
        trade.tags = [];
      }

      let pnl = null;
      let pnlSource = null;

      // Commission: keep imported commission if present, otherwise use instrument default.
      let commission = (trade.commissionSource === "import" && isFinite(parseFloat(trade.commission))) ? parseFloat(trade.commission) : null;
      let commissionSource = (trade.commissionSource === "import" && commission !== null) ? "import" : null;

      if (commission === null && trade.instrumentId) {
        const c = computeDefaultCommission(trade.instrumentId, trade.contracts || 1);
        if (isFinite(c)) {
          commission = c;
          commissionSource = "instrument";
        }
      }

      const pnlEl = document.getElementById("editPnL");
      const pnlMode = pnlEl ? pnlEl.dataset.source : null;

      const tryAuto = () => {
        if (
          trade.instrumentId &&
          trade.entry &&
          trade.sl &&
          trade.tp1 &&
          (trade.result === "Win" || trade.result === "Loss" || trade.result === "Breakeven")
        ) {
          return computeAutoPnLDetail({
            instrumentId: trade.instrumentId,
            direction: trade.direction,
            entry: trade.entry,
            sl: trade.sl,
            tp1: trade.tp1,
            result: trade.result,
            contracts: trade.contracts || 1
          });
        }
        return null;
      };

      if (pnlMode === "auto") {
        const detail = tryAuto();
        if (detail !== null) {
          pnl = detail.pnl;
          pnlSource = "auto";
          commission = detail.commission;
          commissionSource = "instrument";
        } else if (pnlStr !== "") {
          const p = parseFloat(pnlStr);
          if (isFinite(p)) {
            pnl = p;
            pnlSource = "manual";
          }
        }
      } else {
        // Manual mode: honor user value if present, otherwise auto-calc when possible.
        if (pnlStr !== "") {
          const p = parseFloat(pnlStr);
          if (isFinite(p)) {
            pnl = p;
            pnlSource = "manual";
          }
        } else {
          const detail = tryAuto();
          if (detail !== null) {
            pnl = detail.pnl;
            pnlSource = "auto";
            commission = detail.commission;
            commissionSource = "instrument";
          }
        }
      }

      trade.pnl = pnl;
      trade.pnlSource = pnlSource;
      trade.commission = commission;
      trade.commissionSource = commissionSource;


      trade.notes = notes;

      touchTrade(trade);

      saveTradeHistory();
      renderTradeHistory();
      cancelEdit();
      alert("Trade updated.");
    }


    function deleteEditedTrade() {
      if (editingTradeId == null) return;
      const trade = tradeHistory.find(t => t.id === editingTradeId);
      if (!trade) return;
      if (!confirm("Delete this trade from your local history? This cannot be undone.")) return;
      tradeHistory = tradeHistory.filter(t => t.id !== editingTradeId);
      saveTradeHistory();
      renderTradeHistory();
      cancelEdit();
      alert("Trade deleted.");
    }


    function cancelEdit() {
      editingTradeId = null;
      const container = document.getElementById("editContainer");
      if (container) {
        container.style.display = "none";
        container.innerHTML = "";
      }
    }

    function updateProgress() {
      if (!checklistActive) {
        progressFill.style.width = "0%";
        progressLabel.textContent = "";
        sectionLabel.textContent = "";
        return;
      }
      const total = currentQuestions.length;
      const current = Math.min(currentIndex + 1, total);
      const answeredCount = answers.filter(a => a !== null).length;
      const pct = (answeredCount / total) * 100;
      progressFill.style.width = pct + "%";
      progressLabel.textContent = `Question ${current} of ${total}`;

      const section = currentQuestions[currentIndex]?.section || "";
      sectionLabel.textContent = section ? section : "";
    }



    function renderHome() {
      closeAllPopups();
      statusContainer.innerHTML = "";
      checklistActive = false;
      failed = false;
      failReason = "";
      setHomeMode(true);
      updateProgress();

      const editContainer = document.getElementById("editContainer");
      if (editContainer) {
        editContainer.style.display = "none";
        editContainer.innerHTML = "";
      }
      const settingsPanel = document.getElementById("instrumentSettings");
      if (settingsPanel) {
        settingsPanel.style.display = "none";
      }

      questionArea.innerHTML = `
        <div class="question-text">
          Choose a checklist to run for this trade, or skip straight to journaling.
        </div>
        <div class="journal-grid" style="margin-bottom:0.75rem;">
          <div>
            <label for="checklistType">Checklist Type</label>
            <select id="checklistType"></select>
          </div>
          <div>
            <label style="opacity:0;">Editor</label>
            <button class="secondary small" type="button" id="editChecklistsBtn">Edit Checklists</button>
          </div>
        </div>
        <div class="buttons">
          <button class="primary" type="button" id="startChecklistBtn">Start Checklist</button>
          <button class="secondary" type="button" id="homeSkipJournalBtn">Skip to Journal Only</button>
        </div>
      `;

      navButtons.innerHTML = "";

      populateChecklistDropdown();

      const checklistSel = document.getElementById("checklistType");
      if (checklistSel) {
        checklistSel.addEventListener("change", () => {
          settings.lastChecklistKey = checklistSel.value;
          saveSettings();
        });
      }


      const startBtn = document.getElementById("startChecklistBtn");
      const skipBtn = document.getElementById("homeSkipJournalBtn");
      const editBtn = document.getElementById("editChecklistsBtn");
      if (startBtn) {
        startBtn.onclick = () => startChecklist();
      }
      if (skipBtn) {
        skipBtn.onclick = () => skipToJournal();
      }
      if (editBtn) {
        editBtn.onclick = () => renderChecklistEditor();
      }
    }


function startChecklist() {
      closeAllPopups();
      const sel = document.getElementById("checklistType");
      const key = sel ? sel.value : (settings.lastChecklistKey || "orb");

      const list = Array.isArray(settings.checklists) ? settings.checklists : [];
      let chosen = list.find(c => c.key === key);
      if (!chosen && list.length) {
        chosen = list[0];
      }
      if (!chosen) {
        alert("No checklists configured. Open Edit Checklists to create one.");
        return;
      }

      const qs = Array.isArray(chosen.questions) ? chosen.questions : [];
      if (!qs.length) {
        alert("The selected checklist has no questions yet. Opening the editor so you can configure it.");
        renderChecklistEditor(chosen.key);
        return;
      }

      currentQuestions = qs.map((q, idx) => ({
        id: idx + 1,
        section: q.section || "",
        text: q.text || "",
        hardStop: !!q.hardStop,
        failOn: q.failOn || "no"
      }));
      currentChecklistKey = chosen.key;
      settings.lastChecklistKey = chosen.key;
      saveSettings();

      currentIndex = 0;
      answers = new Array(currentQuestions.length).fill(null);
      failed = false;
      failReason = "";
      checklistActive = true;
      renderQuestion();
    }




function populateChecklistDropdown() {
      const sel = document.getElementById("checklistType");
      if (!sel) return;
      sel.innerHTML = "";
      const list = Array.isArray(settings.checklists) ? settings.checklists : [];
      if (!list.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No checklists configured";
        sel.appendChild(opt);
        return;
      }
      list.forEach(c => {
        const opt = document.createElement("option");
        opt.value = c.key;
        opt.textContent = c.name || c.key;
        sel.appendChild(opt);
      });
      if (settings.lastChecklistKey) {
        const found = Array.from(sel.options).find(o => o.value === settings.lastChecklistKey);
        if (found) {
          sel.value = settings.lastChecklistKey;
        }
      }
    }

    function renderChecklistEditor(selectedKey) {
      closeAllPopups();
      setHomeMode(false);
      statusContainer.innerHTML = "";

      const list = Array.isArray(settings.checklists) ? settings.checklists : [];
      let chosen = list.find(c => c.key === selectedKey) || list[0];

      if (!chosen) {
        chosen = {
          key: "new_checklist",
          name: "New Checklist",
          questions: []
        };
        settings.checklists.push(chosen);
        saveSettings();
      }

      const selectOptions = list.map(c => 
        `<option value="${c.key}" ${c.key === chosen.key ? "selected" : ""}>${c.name || c.key}</option>`
      ).join("");

      questionArea.innerHTML = `
        <div class="section-label">Checklist Editor</div>
        <div class="question-text">
          Create and edit your checklists. Changes are saved locally in this browser.
        </div>
        <div class="journal-grid" style="margin-bottom:0.75rem;">
          <div>
            <label for="editorChecklistSelect">Select checklist</label>
            <select id="editorChecklistSelect">
              ${selectOptions}
            </select>
          </div>
          <div>
            <label for="editorChecklistName">Checklist name</label>
            <input id="editorChecklistName" type="text" />
          </div>
        </div>
        <div class="summary" id="checklistQuestionsEditor" style="max-height:260px;overflow-y:auto;"></div>
        <div class="journal-actions">
          <button type="button" class="primary" id="addQuestionBtn">Add Question</button>
          <button type="button" class="secondary" id="newChecklistBtn">New Checklist</button>
          <button type="button" class="secondary" id="deleteChecklistBtn">Delete Checklist</button>
        </div>
      `;

      navButtons.innerHTML = "";
      const backBtn = document.createElement("button");
      backBtn.className = "secondary";
      backBtn.textContent = "Back to Home";
      backBtn.onclick = () => {
        saveChecklistEditorState();
        renderHome();
      };
      navButtons.appendChild(backBtn);

      const nameInput = document.getElementById("editorChecklistName");
      if (nameInput) {
        nameInput.value = chosen.name || "";
        nameInput.addEventListener("input", () => {
          const list2 = Array.isArray(settings.checklists) ? settings.checklists : [];
          const c = list2.find(x => x.key === chosen.key);
          if (c) {
            c.name = nameInput.value || c.key;
            saveSettings();
          }
        });
      }

      const selectEl = document.getElementById("editorChecklistSelect");
      if (selectEl) {
        const currentKey = chosen.key;
        selectEl.addEventListener("change", () => {
          // Save edits to the previously selected checklist (currentKey),
          // then re-render editor for the newly selected checklist.
          saveChecklistEditorState(currentKey);
          renderChecklistEditor(selectEl.value);
        });
      }

      const addBtn = document.getElementById("addQuestionBtn");
      if (addBtn) {
        addBtn.addEventListener("click", () => {
          const list3 = Array.isArray(settings.checklists) ? settings.checklists : [];
          const c = list3.find(x => x.key === (selectEl ? selectEl.value : chosen.key));
          if (c) {
            const nextId = (c.questions || []).length + 1;
            c.questions = c.questions || [];
            c.questions.push({
              id: nextId,
              section: "",
              text: "",
              hardStop: true,
              failOn: "no"
            });
            saveSettings();
            renderChecklistEditor(c.key);
          }
        });
      }

      const newBtn = document.getElementById("newChecklistBtn");
      if (newBtn) {
        newBtn.addEventListener("click", () => {
          saveChecklistEditorState();
          const baseKey = "custom";
          let i = 1;
          let newKey = baseKey + i;
          const list4 = Array.isArray(settings.checklists) ? settings.checklists : [];
          while (list4.some(c => c.key === newKey)) {
            i++;
            newKey = baseKey + i;
          }
          const created = {
            key: newKey,
            name: "Custom Checklist " + i,
            questions: []
          };
          list4.push(created);
          saveSettings();
          renderChecklistEditor(created.key);
        });
      }

      const delBtn = document.getElementById("deleteChecklistBtn");
      if (delBtn) {
        delBtn.addEventListener("click", () => {
          const list5 = Array.isArray(settings.checklists) ? settings.checklists : [];
          if (list5.length <= 1) {
            alert("You must have at least one checklist.");
            return;
          }
          const keyToDelete = selectEl ? selectEl.value : chosen.key;
          if (!window.confirm("Delete this checklist? This cannot be undone.")) return;
          const idx = list5.findIndex(c => c.key === keyToDelete);
          if (idx >= 0) {
            list5.splice(idx, 1);
            saveSettings();
            const next = list5[0];
            renderChecklistEditor(next.key);
          }
        });
      }

      renderChecklistQuestionsEditor(chosen.key);
    }

    function renderChecklistQuestionsEditor(checklistKey) {
      const list = Array.isArray(settings.checklists) ? settings.checklists : [];
      const checklist = list.find(c => c.key === checklistKey);
      const container = document.getElementById("checklistQuestionsEditor");
      if (!container) return;
      container.innerHTML = "";
      if (!checklist || !Array.isArray(checklist.questions) || !checklist.questions.length) {
        container.innerHTML = '<div class="tip">No questions yet. Click "Add Question" to create one.</div>';
        return;
      }
      checklist.questions.forEach((q, idx) => {
        const row = document.createElement("div");
        row.className = "summary-item";
        row.dataset.index = String(idx);
        row.innerHTML = `
          <div style="flex:1;min-width:0;">
            <label style="font-size:0.75rem;">Section</label>
            <input type="text" class="editor-section" value="${q.section || ""}" />
            <label style="font-size:0.75rem;margin-top:0.35rem;">Question</label>
            <textarea class="editor-text" rows="2">${q.text || ""}</textarea>
          </div>
          <div style="width:150px;flex-shrink:0;padding-left:0.5rem;">
            <label style="font-size:0.75rem;">Hard stop?</label>
            <select class="editor-hardstop">
              <option value="true"${q.hardStop ? " selected" : ""}>Yes</option>
              <option value="false"${!q.hardStop ? " selected" : ""}>No</option>
            </select>
            <label style="font-size:0.75rem;margin-top:0.35rem;">Fail on answer</label>
            <select class="editor-failon">
              <option value="no"${q.failOn === "no" ? " selected" : ""}>No</option>
              <option value="yes"${q.failOn === "yes" ? " selected" : ""}>Yes</option>
            </select>
            <button type="button" class="small danger editor-delete-question" style="margin-top:0.5rem;">Delete</button>
          </div>
        `;
        container.appendChild(row);
      });

      container.onclick = function(e) {
        const btn = e.target.closest(".editor-delete-question");
        if (!btn) return;
        const row = btn.closest(".summary-item");
        if (!row) return;
        const idx = parseInt(row.dataset.index, 10);
        if (isNaN(idx)) return;
        const list2 = Array.isArray(settings.checklists) ? settings.checklists : [];
        const c = list2.find(c2 => c2.key === checklistKey);
        if (!c || !Array.isArray(c.questions)) return;
        c.questions.splice(idx, 1);
        c.questions.forEach((qq, i2) => { qq.id = i2 + 1; });
        saveSettings();
        renderChecklistQuestionsEditor(checklistKey);
      };
    }

    function saveChecklistEditorState(forceKey) {
      const container = document.getElementById("checklistQuestionsEditor");
      const selectEl = document.getElementById("editorChecklistSelect");
      if (!container || !selectEl) return;
      const key = forceKey || selectEl.value;
      const list = Array.isArray(settings.checklists) ? settings.checklists : [];
      const checklist = list.find(c => c.key === key);
      if (!checklist) return;

      const rows = container.querySelectorAll(".summary-item");
      const questions = [];
      rows.forEach((row, idx) => {
        const sectionInput = row.querySelector(".editor-section");
        const textArea = row.querySelector(".editor-text");
        const hardSel = row.querySelector(".editor-hardstop");
        const failSel = row.querySelector(".editor-failon");
        questions.push({
          id: idx + 1,
          section: sectionInput ? sectionInput.value : "",
          text: textArea ? textArea.value : "",
          hardStop: hardSel ? hardSel.value === "true" : true,
          failOn: failSel ? failSel.value : "no"
        });
      });
      checklist.questions = questions;
      saveSettings();
    }

function renderQuestion() {
      statusContainer.innerHTML = "";
      setHomeMode(false);
      updateProgress();

      if (failed) {
        renderFail();
        return;
      }

      if (currentIndex >= currentQuestions.length) {
        renderJournalScreen(true);
        return;
      }

      const q = currentQuestions[currentIndex];
      const idxDisplay = currentIndex + 1;
      const storedAnswer = answers[currentIndex];

      questionArea.innerHTML = `
        <div class="section-label">${q.section}</div>
        <div class="question-index">Checklist item ${idxDisplay} of ${currentQuestions.length}</div>
        <div class="question-text">${q.text}</div>
      `;

      navButtons.innerHTML = "";

      const yesBtn = document.createElement("button");
      yesBtn.className = "primary";
      yesBtn.innerHTML = "Yes";
      yesBtn.onclick = () => handleAnswer("yes");

      const noBtn = document.createElement("button");
      noBtn.className = "danger";
      noBtn.innerHTML = "No";
      noBtn.onclick = () => handleAnswer("no");

      navButtons.appendChild(yesBtn);
      navButtons.appendChild(noBtn);

      if (currentIndex > 0) {
        const backBtn = document.createElement("button");
        backBtn.className = "secondary";
        backBtn.textContent = "Back";
        backBtn.onclick = () => {
          if (currentIndex > 0) {
            currentIndex--;
            failed = false;
            failReason = "";
            renderQuestion();
          }
        };
        navButtons.appendChild(backBtn);
      }

      const resetBtn = document.createElement("button");
      resetBtn.className = "secondary";
      resetBtn.textContent = "Reset Checklist";
      resetBtn.onclick = resetChecklist;
      navButtons.appendChild(resetBtn);

      const skipBtn = document.createElement("button");
      skipBtn.className = "secondary";
      skipBtn.textContent = "Skip to Journal Only";
      skipBtn.onclick = skipToJournal;
      navButtons.appendChild(skipBtn);

      if (storedAnswer) {
        const statusPill = document.createElement("div");
        const failOn = (q && typeof q.failOn === "string") ? q.failOn : "no";
        const storedIsFail = storedAnswer === failOn;
        statusPill.className = "status-pill " + (storedIsFail ? "status-fail" : "status-ok");
        statusPill.innerHTML = storedAnswer === "yes"
          ? ("Last answer for this question: Yes" + (storedIsFail ? " (fails rule)" : ""))
          : ("Last answer for this question: No" + (storedIsFail ? " (fails rule)" : ""));
        statusContainer.appendChild(statusPill);
      }
    }

    function handleAnswer(value) {
      const q = currentQuestions[currentIndex];
      answers[currentIndex] = value;

      if (q.hardStop && value === q.failOn) {
        failed = true;
        failReason = q.text;
        renderQuestion();
        return;
      }

      currentIndex++;
      renderQuestion();
    }

    function resetChecklist() {
      currentIndex = 0;
      answers = new Array(currentQuestions.length).fill(null);
      failed = false;
      failReason = "";
      checklistActive = true;
      renderQuestion();
    }

    function skipToJournal() {
      closeAllPopups();
      answers = new Array(currentQuestions.length).fill(null);
      currentIndex = currentQuestions.length;
      failed = false;
      failReason = "";
      checklistActive = false;
      renderJournalScreen(false);
    }


function renderFail() {
      setHomeMode(false);
      const answeredCount = answers.filter(a => a !== null).length;

      const nowLocal = toDatetimeLocalValue(new Date());

      questionArea.innerHTML = `
        <div class="section-label">Failed Rules</div>
        <div class="question-text">
          ❌ Checklist blocked this trade.<br/><br/>
          You failed on:<br/><br/>
          <strong>${failReason}</strong>
        </div>
        <div class="summary">
          <div class="summary-item">
            <span>Questions answered</span>
            <span>${answeredCount} / ${currentQuestions.length}</span>
          </div>
        </div>
        <div class="journal-form">
          <div style="font-size:0.9rem;color:#e5e7eb;margin-bottom:0.5rem;">Log as Skipped / Rule-Break</div>
          <div class="journal-grid">
            <div>
              <label for="failTimestamp">Date & Time</label>
              <input id="failTimestamp" type="datetime-local" value="${nowLocal}" />
            </div>
            <div>
              <label for="failSymbol">Symbol</label>
              <input id="failSymbol" type="text" placeholder="MESZ5" />
            </div>
            <div>
              <label for="failDirection">Direction</label>
              <select id="failDirection">
                <option value="">Select…</option>
                <option value="Long">Long</option>
                <option value="Short">Short</option>
              </select>
            </div>
            <div>
              <label for="failTaken">Taken anyway?</label>
              <select id="failTaken">
                <option value="No">No (skipped)</option>
                <option value="Yes">Yes (broke rules)</option>
              </select>
            </div>
            <div>
              <label for="failResult">Result</label>
              <select id="failResult">
                <option value="Pending">Pending</option>
                <option value="Win">Win</option>
                <option value="Loss">Loss</option>
                <option value="Breakeven">Breakeven</option>
                <option value="Cancelled">Cancelled</option>
              </select>
            </div>
          </div>
          <div>
            <label for="failNotes">Notes</label>
            <textarea id="failNotes" rows="2" placeholder="Why it failed, what you’ll do next time."></textarea>
          </div>
          <div class="journal-actions">
            <button type="button" class="primary" id="failSaveBtn">Save to Journal</button>
          </div>
        </div>
      `;

      navButtons.innerHTML = "";

      const resetBtn = document.createElement("button");
      resetBtn.className = "primary";
      resetBtn.textContent = "Start Over";
      resetBtn.onclick = resetChecklist;
      navButtons.appendChild(resetBtn);

      const ignoreBtn = document.createElement("button");
      ignoreBtn.className = "secondary";
      ignoreBtn.textContent = "Ignore & Continue (not recommended)";
      ignoreBtn.onclick = () => {
        failed = false;
        currentIndex++;
        renderQuestion();
      };
      navButtons.appendChild(ignoreBtn);

      const statusPill = document.createElement("div");
      statusPill.className = "status-pill status-fail";
      statusPill.innerHTML = "The checklist is doing its job, You idiot. If you override it, mark that in the journal.";
      statusContainer.appendChild(statusPill);

      const failSaveBtn = document.getElementById("failSaveBtn");
      if (failSaveBtn) {
        failSaveBtn.onclick = saveJournalFromFail;
      }
    }

    
    function toDatetimeLocalValue(date) {
      const pad = (n) => String(n).padStart(2, "0");
      const yyyy = date.getFullYear();
      const mm = pad(date.getMonth() + 1);
      const dd = pad(date.getDate());
      const hh = pad(date.getHours());
      const mi = pad(date.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
    }

function renderJournalScreen(fromChecklist) {
      setHomeMode(false);
      const headerLabel = fromChecklist ? "Checklist Passed" : "Journal Only";
      const message = fromChecklist
        ? "✅ All mandatory questions passed.<br/><br/>You are cleared to execute this ORB midpoint trade <strong>according to your plan</strong>."
        : "✏️ Journal-only entry.<br/><br/>Use this to log trades when you didn\u2019t use the checklist (for example, backfilling past trades).";

      const instrumentOptions = getInstrumentOptionsHtml(settings.lastInstrumentId || "");

      const nowLocal = toDatetimeLocalValue(new Date());

      questionArea.innerHTML = `
        <div class="section-label">${headerLabel}</div>
        <div class="question-text">
          ${message}
        </div>
        <div class="summary" id="summaryWrapper"></div>
        <div class="journal-form">
          <div style="font-size:0.9rem;color:#e5e7eb;margin-bottom:0.5rem;">Trade Journal</div>
          <div class="journal-grid">
            <div>
              <label for="journalTimestamp">Date & Time</label>
              <input id="journalTimestamp" type="datetime-local" value="${nowLocal}" />
            </div>
            <div>
              <label for="journalDirection">Direction</label>
              <select id="journalDirection">
                <option value="">Select…</option>
                <option value="Long">Long</option>
                <option value="Short">Short</option>
              </select>
            </div>
            <div>
              <label for="journalInstrument">Instrument</label>
              <select id="journalInstrument">
                ${instrumentOptions}
              </select>
            </div>
            <div>
              <label for="journalContracts">Contracts</label>
              <input id="journalContracts" type="number" min="1" step="1" value="1" />
            </div>
            <div>
              <label for="journalEntry">Entry Price</label>
              <input id="journalEntry" type="number" step="0.25" />
            </div>
            <div>
              <label for="journalSL">Stop Loss</label>
              <input id="journalSL" type="number" step="0.25" />
            </div>
            <div>
              <label for="journalTP1">Take Profit 1</label>
              <input id="journalTP1" type="number" step="0.25" />
            </div>
            <div>
              <label for="journalTP2">Take Profit 2 (optional)</label>
              <input id="journalTP2" type="number" step="0.25" />
            </div>
            <div>
              <label for="journalResult">Result</label>
              <select id="journalResult">
                <option value="Pending">Pending</option>
                <option value="Win">Win</option>
                <option value="Loss">Loss</option>
                <option value="Breakeven">Breakeven</option>
                <option value="Cancelled">Cancelled</option>
              </select>
            </div>
            <div>
              <label for="journalRMultiple">R-Multiple (optional)</label>
              <input id="journalRMultiple" type="number" step="0.1" />
            </div>
          </div>
          <div id="riskPreview" class="tip" style="margin-top:0.25rem;font-size:0.75rem;">
            Fill instrument, direction, entry, SL, TP1, and contracts to see risk / reward.
          </div>
          <div style="margin-top:0.5rem;">
            <label for="journalPnL">Realized PnL ($, optional)</label>
            <input id="journalPnL" type="number" step="0.01" />
          </div>
          <div>
            <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;">
              <label style="margin-bottom:0;">Tags</label>
              <button type="button" class="small secondary" onclick="openTagSettings()" title="Edit default tag suggestions">
                ⚙ Tags
              </button>
            </div>
            <div id="journalTagSuggestions" class="tags-line"></div>
            <div id="journalTagList" class="tags-line"></div>
            <input id="journalTagInput" type="text" placeholder="Type a tag and press Enter or click a suggestion" />
          </div>
          <div>
            <label for="journalNotes">Notes</label>
            <textarea id="journalNotes" rows="2" placeholder="Why you took the trade, confluence, emotions, etc."></textarea>
          </div>
          <div class="journal-actions">
            <button type="button" class="primary" id="journalSaveBtn">Save Trade to Journal</button>
            <button type="button" class="secondary" id="journalSkipBtn">Cancel (Back to Home)</button>
          </div>
        </div>
      `;

      const summaryWrapper = document.getElementById("summaryWrapper");
      if (fromChecklist && summaryWrapper) {
        currentQuestions.forEach((q, idx) => {
          const ansRaw = answers[idx];
          const ans = ansRaw || "not answered";
          const failOn = (q && typeof q.failOn === "string") ? q.failOn : "no";
          const isFail = ansRaw === failOn;
          const ansClass = ansRaw ? (isFail ? "answer-fail" : "answer-pass") : "answer-na";

          const div = document.createElement("div");
          div.className = "summary-item";
          div.innerHTML = `
            <span>${idx + 1}. ${q.section}</span>
            <span class="${ansClass}">${ans}</span>
          `;
          summaryWrapper.appendChild(div);
        });
      } else if (!fromChecklist && summaryWrapper) {
        summaryWrapper.innerHTML = `
          <div class="summary-item">
            <span>Checklist</span>
            <span>Not used for this entry</span>
          </div>
        `;
      }

      navButtons.innerHTML = "";

      const statusPill = document.createElement("div");
      statusPill.className = "status-pill " + (fromChecklist ? "status-ok" : "status-fail");
      statusPill.innerHTML = fromChecklist
        ? "Nice. Now execute the trade exactly as planned and journal it."
        : "Journal-only mode. This trade will be logged without a checklist pass.";
      statusContainer.appendChild(statusPill);

      const saveBtn = document.getElementById("journalSaveBtn");
      const skipBtn = document.getElementById("journalSkipBtn");
      if (saveBtn) {
        saveBtn.onclick = () => saveJournal(fromChecklist);
      }
      if (skipBtn) {
        skipBtn.onclick = () => {
          renderHome();
        };
      }

      attachJournalInputListeners();
    }

    
    function getJournalTagsFromDOM() {
      const list = document.getElementById("journalTagList");
      if (!list) return [];
      const pills = list.querySelectorAll(".tag-pill");
      return Array.from(pills)
        .map(p => p.dataset.tag || p.textContent.trim())
        .filter(Boolean);
    }

    function renderTagSuggestions() {
      const container = document.getElementById("journalTagSuggestions");
      if (!container) return;
      container.innerHTML = "";
      const tags = (settings.tagSuggestions && Array.isArray(settings.tagSuggestions))
        ? settings.tagSuggestions
        : ["ORB","A+ setup","News day","FOMO","Overtraded","Rule break"];
      tags.forEach(tag => {
        const span = document.createElement("span");
        span.className = "tag-pill tag-suggestion";
        span.dataset.tag = tag;
        span.textContent = tag;
        container.appendChild(span);
      });
    }

    function addJournalTag(text) {
      const list = document.getElementById("journalTagList");
      if (!list) return;
      const tag = text.trim();
      if (!tag) return;
      const existing = Array.from(list.querySelectorAll(".tag-pill"))
        .map(p => (p.dataset.tag || p.textContent).toLowerCase());
      if (existing.includes(tag.toLowerCase())) return;
      const span = document.createElement("span");
      span.className = "tag-pill";
      span.textContent = tag;
      span.dataset.tag = tag;
      list.appendChild(span);
    }

    function openTagSettings() {
      const current = (settings.tagSuggestions && Array.isArray(settings.tagSuggestions))
        ? settings.tagSuggestions.join(", ")
        : ["ORB","A+ setup","News day","FOMO","Overtraded","Rule break"];
      const next = window.prompt("Edit default tag suggestions (comma-separated):", current);
      if (next === null) return;
      const arr = next.split(",").map(s => s.trim()).filter(Boolean);
      if (!arr.length) return;
      settings.tagSuggestions = arr;
      saveSettings();
      renderTagSuggestions();
    }

    function setupJournalTagInput() {
      const input = document.getElementById("journalTagInput");
      const list = document.getElementById("journalTagList");
      const suggestions = document.getElementById("journalTagSuggestions");
      if (!input || !list || !suggestions) return;

      // render suggestions fresh each time
      renderTagSuggestions();

      if (!input.dataset.listenerAttached) {
        input.addEventListener("keydown", function(e) {
          if (e.key === "Enter" && input.value.trim() !== "") {
            e.preventDefault();
            addJournalTag(input.value.trim());
            input.value = "";
          }
        });
        input.dataset.listenerAttached = "true";
      }

      if (!list.dataset.listenerAttached) {
        list.addEventListener("click", function(e) {
          const pill = e.target.closest(".tag-pill");
          if (pill) {
            pill.remove();
          }
        });
        list.dataset.listenerAttached = "true";
      }

      if (!suggestions.dataset.listenerAttached) {
        suggestions.addEventListener("click", function(e) {
          const pill = e.target.closest(".tag-suggestion");
          if (pill && pill.dataset.tag) {
            addJournalTag(pill.dataset.tag);
          }
        });
        suggestions.dataset.listenerAttached = "true";
      }
    }

function attachJournalInputListeners() {
      const ids = ["journalInstrument","journalDirection","journalEntry","journalSL","journalTP1","journalContracts"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener("input", updateRiskPreviewFromJournal);
        if (el.tagName === "SELECT") {
          el.addEventListener("change", updateRiskPreviewFromJournal);
        }
      });
      updateRiskPreviewFromJournal();
      setupJournalTagInput();
    }

    function updateRiskPreviewFromJournal() {
      const getEl = id => document.getElementById(id);
      const instId = getEl("journalInstrument") ? getEl("journalInstrument").value : "";
      const dir = getEl("journalDirection") ? getEl("journalDirection").value : "";
      const entry = getEl("journalEntry") ? parseFloat(getEl("journalEntry").value) : NaN;
      const sl = getEl("journalSL") ? parseFloat(getEl("journalSL").value) : NaN;
      const tp1 = getEl("journalTP1") ? parseFloat(getEl("journalTP1").value) : NaN;
      const contracts = getEl("journalContracts") ? parseFloat(getEl("journalContracts").value || "1") : NaN;
      const out = getEl("riskPreview");
      if (!out) return;

      if (!instId || !dir || !isFinite(entry) || !isFinite(sl) || !isFinite(tp1) || !isFinite(contracts) || contracts <= 0) {
        out.textContent = "Fill instrument, direction, entry, SL, TP1, and contracts to see risk / reward.";
        return;
      }

      const inst = (settings.instruments || []).find(i => i.id === instId);
      if (!inst || inst.tickSize == null || inst.tickValue == null) {
        out.textContent = "Instrument is missing tick size or tick value. Configure it in Instrument Settings.";
        return;
      }

      const tickSize = parseFloat(inst.tickSize);
      const tickValue = parseFloat(inst.tickValue);
      if (!isFinite(tickSize) || tickSize <= 0 || !isFinite(tickValue) || tickValue <= 0) {
        out.textContent = "Instrument tick settings are invalid.";
        return;
      }

      const priceRisk = Math.abs(entry - sl);
      const ticksRisk = priceRisk / tickSize;
      const riskPerContract = ticksRisk * tickValue;
      const totalRisk = riskPerContract * contracts;

      let rewardDiff;
      if (dir === "Long") rewardDiff = tp1 - entry;
      else if (dir === "Short") rewardDiff = entry - tp1;
      else rewardDiff = 0;

      const ticksReward = rewardDiff / tickSize;
      const rewardPerContract = ticksReward * tickValue;
      const totalReward = rewardPerContract * contracts;

      const commission = computeDefaultCommission(instId, contracts);
      const netRisk = totalRisk + (commission || 0);
      const netReward = totalReward - (commission || 0);

      let rrText = "";
      if (riskPerContract > 0) {
        const rMultiple = rewardPerContract / riskPerContract;
        rrText = ` · R/R ~ ${rMultiple.toFixed(2)}R`;
      }

      const signReward = totalReward >= 0 ? "+" : "";
      out.textContent =
        `Risk per contract: ${ticksRisk.toFixed(1)} ticks ($${riskPerContract.toFixed(2)}), position: $${totalRisk.toFixed(2)}. ` +
        `Reward to TP1: ${ticksReward.toFixed(1)} ticks (${signReward}$${totalReward.toFixed(2)})${rrText}.` +
        ((commission && commission > 0)
          ? ` Est comm: $${commission.toFixed(2)} · Net risk: $${netRisk.toFixed(2)} · Net reward: ${(netReward >= 0 ? "+" : "")}$${netReward.toFixed(2)}.`
          : ``);
    }

    function saveJournal(fromChecklist) {
      const direction = document.getElementById("journalDirection").value;
      const instrumentId = document.getElementById("journalInstrument").value;
      const contractsRaw = document.getElementById("journalContracts").value || "1";
      const entry = document.getElementById("journalEntry").value;
      const sl = document.getElementById("journalSL").value;
      const tp1 = document.getElementById("journalTP1").value;
      const tp2 = document.getElementById("journalTP2").value;
      const result = document.getElementById("journalResult").value;
      const rMultiple = document.getElementById("journalRMultiple").value;
      const pnlStr = document.getElementById("journalPnL").value;
      const notes = document.getElementById("journalNotes").value.trim();

      const tsVal = (document.getElementById("journalTimestamp") || {}).value || "";
      let timestamp = null;
      if (tsVal) {
        const d = new Date(tsVal);
        if (!isNaN(d.getTime())) timestamp = d.toISOString();
      }
      if (!timestamp) timestamp = new Date().toISOString();

      if (!direction) {
        alert("Please at least fill Direction.");
        return;
      }

      const tags = getJournalTagsFromDOM();

      const contractsNum = contractsRaw ? parseFloat(contractsRaw) : 1;
      const contracts = isFinite(contractsNum) && contractsNum > 0 ? contractsNum : 1;

      let pnl = null;
      let pnlSource = null;
      let commission = null;
      let commissionSource = null;

      if (pnlStr !== "") {
        const p = parseFloat(pnlStr);
        if (isFinite(p)) {
          pnl = p;
          pnlSource = "manual";
        }
      }

      // Default commission from instrument settings (optional)
      if (instrumentId) {
        const c = computeDefaultCommission(instrumentId, contracts);
        if (isFinite(c)) {
          commission = c;
          commissionSource = "instrument";
        }
      }

      if (
        pnl === null &&
        instrumentId &&
        entry &&
        sl &&
        tp1 &&
        (result === "Win" || result === "Loss" || result === "Breakeven")
      ) {
        const detail = computeAutoPnLDetail({
          instrumentId,
          direction,
          entry,
          sl,
          tp1,
          result,
          contracts
        });
        if (detail !== null) {
          pnl = detail.pnl;
          pnlSource = "auto";
          commission = detail.commission;
          commissionSource = "instrument";
        }
      }

            const checklistKey = fromChecklist ? (currentChecklistKey || null) : null;
      const chosenChecklist = checklistKey && Array.isArray(settings.checklists)
        ? settings.checklists.find(c => c.key === checklistKey)
        : null;
      const checklistName = chosenChecklist ? (chosenChecklist.name || null) : null;
      const checklistScore = fromChecklist ? computeChecklistScore(currentQuestions, answers) : null;
      const checklistSnapshot = fromChecklist ? buildChecklistSnapshot(currentQuestions, answers) : null;

const trade = {
        id: Date.now(),
        timestamp,
        symbol: instrumentId || null,
        direction,
        instrumentId: instrumentId || null,
        contracts,
        entry: entry || null,
        sl: sl || null,
        tp1: tp1 || null,
        tp2: tp2 || null,
        result: result || "Pending",
        rMultiple: rMultiple || null,
        pnl,
        pnlSource,
        commission,
        commissionSource,
        notes,
        tags,
        checklistKey,
        checklistName,
        checklistScore,
        checklistSnapshot,
        checklistPassed: fromChecklist ? true : null,
        failReason: null
      };

      if (instrumentId) {
        settings.lastInstrumentId = instrumentId;
        saveSettings();
      }

      addTrade(trade);
      alert("Trade saved to local journal.");
      renderHome();
    }

function saveJournalFromFail() {
      const symbol = document.getElementById("failSymbol").value.trim();
      const direction = document.getElementById("failDirection").value;
      const taken = document.getElementById("failTaken").value;
      const result = document.getElementById("failResult").value;
      const notes = document.getElementById("failNotes").value.trim();

      const tsVal = (document.getElementById("failTimestamp") || {}).value || "";
      let timestamp = null;
      if (tsVal) {
        const d = new Date(tsVal);
        if (!isNaN(d.getTime())) timestamp = d.toISOString();
      }
      if (!timestamp) timestamp = new Date().toISOString();

      if (!symbol && !direction && !notes) {
        alert("Add at least some details before saving.");
        return;
      }

            const checklistKey = currentChecklistKey || null;
      const chosenChecklist = checklistKey && Array.isArray(settings.checklists)
        ? settings.checklists.find(c => c.key === checklistKey)
        : null;
      const checklistName = chosenChecklist ? (chosenChecklist.name || null) : null;
      const checklistScore = computeChecklistScore(currentQuestions, answers);
      const checklistSnapshot = buildChecklistSnapshot(currentQuestions, answers);

const trade = {
        id: Date.now(),
        timestamp,
        symbol,
        direction,
        instrumentId: null,
        contracts: null,
        entry: null,
        sl: null,
        tp1: null,
        tp2: null,
        result: taken === "Yes" ? result : "Blocked",
        rMultiple: null,
        pnl: null,
        notes: (taken === "Yes" ? "[Rule break] " : "[Blocked] ") + notes,
        tags: [],
        checklistKey,
        checklistName,
        checklistScore,
        checklistSnapshot,
        checklistPassed: false,
        failReason
      };

      addTrade(trade);
      alert("Checklist failure logged.");
    }

    loadSettings();
    loadStatsScope();
    loadTradeHistory();
    renderTradeHistory();
    renderInstrumentSettings();
    renderHome();
    // Cloud Sync (GitHub-backed)
    bootstrapCloudSync();

    const importInput = document.getElementById("importFile");
    if (importInput) {
      importInput.addEventListener("change", handleImportFile);
    }
    const tvCsvInput = document.getElementById("tvCsvFile");
    if (tvCsvInput) {
      tvCsvInput.addEventListener("change", handleImportTradingViewCsv);
    }
  </script>
</body>
</html>

